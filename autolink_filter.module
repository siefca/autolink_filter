<?php

/**
* @file
* autolink_filter.module
* 
* @author PaweÅ‚ Wilk
* @link http://github.com/siefca/autolink_filter
*
* Provides automatic linking filter for input formats.
*/

/**
* Implements hook_init().
*/
function autolink_filter_init() {
  $path = drupal_get_path('module', 'autolink_filter');
}

/**
* Implements hook_filter_info().
*/
function autolink_filter_filter_info() {
  static $excluded_tags    = 'a link pre h1 h2 h3 h4 h5 h6 h7 code pre address';
  static $excluded_classes = 'nolink caption';
  static $excluded_words   = 'or m of to too then when on off had been for were less i you he she it more and but no yes they';
  $filters = array();
  $filters['autolink_filter'] = array(
    'title'             => t('Auto-link terms'),
    'process callback'  => '_autolink_filter_process_filter',
    'settings callback' => '_autolink_filter_settings',
    'weight'            => 50,
    'default settings'  => array(
      'excluded_tags'   => $excluded_tags,
      'excluded_classes'=> $excluded_classes,
      'excluded_words'  => $excluded_words,
      'vocabularies'    => _autolink_filter_vocab_array(),
      'processing_options' => array('use_tooltips', 'use_description', 'use_synonyms'),
      'max_terms'       => 4,
      'max_words'       => 1,
      'min'             => 2,
      'max'             => 32,
    ),
  );
  return $filters;
}

/**
* Renders processing options array.
*/
function _autolink_filter_processing_options_array() {
  return array(
    'leaves_only'         => t('Only use terms that are the last children (leaves) of a taxonomy tree.'),
    'selected_only'       => t('Only use terms that have <code>field_autolink</code> boolean field set.'),
    'use_tooltips'        => t('Generate tooltips (uses <code>field_autolink_tooltip</code> text fields from taxonomy terms).'),
    'use_description'     => t('Use description field for tooltips when a tooltip field does not exist or is empty.'),
    'use_synonyms'        => t('Use taxonomy synonyms if available.'),
    'use_virtual_synonyms'=> t('Use virtual synonyms created from all parent term names joined.'),
  );
}

/**
* Gets vocabularies as an array.
*/
function _autolink_filter_vocab_array() {
  $checklist_vocab_array = array();
  $vocabulary = taxonomy_get_vocabularies();
  foreach ($vocabulary as $item) {
    $checklist_vocab_array[$item->vid] = $item->name;
  }
  unset($item);
  return $checklist_vocab_array;
}

/**
 * Settings callback.
 */
function _autolink_filter_settings($form, &$form_state, $filter, $format, $defaults, $filters) {
  $filter->settings += $defaults;
  return array(
    'reminder' => array(
      '#type'   => 'item',
      '#title'  => t('In most cases, Autolink Filter should be the <em>last</em> filter in the &ldquo;Filter processing order&rdquo; list. It is also recommended to run &ldquo;@htmlcorrector_name&rdquo; after this filter, when tooltips are in use.', array('@htmlcorrector_name' => t('Correct faulty and chopped off HTML'))),
      '#weight' => -40,
    ),
    'processing_options' => array(
      '#type'           => 'checkboxes',
      '#title'          => t('Processing options'),
      '#position'       => 'left',
      '#options'        => _autolink_filter_processing_options_array(),
      '#default_value'  => $filter->settings['processing_options'],
      '#weight'         => -30,
      '#description'    => t('Select desirable processing options.'),
    ),
    'excluded_tags' => array(
      '#type'           => 'textfield',
      '#title'          => t('HTML tags excluded from processing'),
      '#default_value'  => $filter->settings['excluded_tags'],
      '#size'           => '63',
      '#weight'         => -20,
      '#description'    => t('Enter HTML tag names (separated by spaces and/or commas) for which a content (contained within) will not be processed.'),
    ),
    'excluded_classes' => array(
      '#type'           => 'textfield',
      '#title'          => t('HTML classes excluded from processing'),
      '#default_value'  => $filter->settings['excluded_classes'],
      '#size'           => '63',
      '#weight'         => -10,
      '#description'    => t('Enter HTML class attribute values (separated by spaces and/or commas) for which a content (contained within) will not be processed.'),
    ),
    'excluded_words' => array(
      '#type'           => 'textfield',
      '#title'          => t('Words excluded from processing'),
      '#default_value'  => $filter->settings['excluded_words'],
      '#size'           => '63',
      '#weight'         => -8,
      '#description'    => t('Enter words (separated by spaces and/or commas) which won\'t be processed.'),
    ),
    'min'               => array(
      '#type'           => 'textfield',
      '#title'          => t('Minimum length of a word'),
      '#default_value'  => $filter->settings['min'],
      '#size'           => '3',
      '#maxlength'      => '4',
      '#element_validate' => array('_autolink_filter_length_validate'),
      '#weight'         => -6,
      '#description'    => t('The minimum acceptable number of letters in a word to be processed (@min to @max)',
                            array('@min' => 0, '@max' => 32)),
    ),
      'max'             => array(
      '#type'           => 'textfield',
      '#title'          => t('Maximum length of a word'),
      '#default_value'  => $filter->settings['max'],
      '#size'           => '3',
      '#maxlength'      => '4',
      '#element_validate' => array('_autolink_filter_length_validate'),
      '#weight'         => -4,
      '#description'    => t('The maximum acceptable number of letters in a word to be processed (@min to @max)',
                            array('@min' => 1, '@max' => 32)),
    ),
    'max_terms'         => array(
      '#type'           => 'textfield',
      '#title'          => t('Maximum number of instances of the same term (including synonyms) to be linked'),
      '#default_value'  => $filter->settings['max_terms'],
      '#size'           => '3',
      '#maxlength'      => '4',
      '#element_validate' => array('_autolink_filter_length_validate'),
      '#weight'         => -2,
      '#description'    => t('The maximum acceptable number of term instances to be processed (0 disables the limit)'),
    ),
      'max_words'       => array(
      '#type'           => 'textfield',
      '#title'          => t('Maximum number of instances of the same word to be linked'),
      '#default_value'  => $filter->settings['max_words'],
      '#size'           => '3',
      '#maxlength'      => '4',
      '#element_validate' => array('_autolink_filter_length_validate'),
      '#weight'         => -1,
      '#description'    => t('The maximum acceptable number of word instances to be processed (0 disables the limit)'),
    ),
    'vocabularies' => array(
      '#type'           => 'checkboxes',
      '#title'          => t('Vocabularies'),
      '#position'       => 'left',
      '#options'        => _autolink_filter_vocab_array(),
      '#default_value'  => $filter->settings['vocabularies'],
      '#weight'         => 0,
      '#description'    => t('Select taxonomy vocabularies used to seek for linked keywords.'),
    )
  );
}

/**
 * Element validate callback for fields that contain lengths.
 * 
 * @param array $element form element
 * @param array $form_state state of a form
 * @param array $form form
 * @return void
 */
function _autolink_filter_length_validate($element, $form_state, $form) {
  if (!empty($element['#value']) && !is_numeric($element['#value'])) {
    form_error($element, t('@element should only contain numbers.', array('@element' => $element['#title'])));
  }

  settype($element['#value'], 'integer');
  $val = $element['#value'];
  $errmin = FALSE;
  $errmax = FALSE;

  switch(end($element['#array_parents'])) {
    case 'min':
      if ($val < 0)  { $errmin = 0;  }
      if ($val > 32) { $errmax = 32; }
      break;
    case 'max':
      if ($val < 1)  { $errmin = 1;  }
      if ($val > 32) { $errmax = 32; }
      break;
    case 'max_terms':
      break;
      if ($val < 0) { $errmin = 0; }
    case 'max_words':
      if ($val < 0) { $errmin = 0; }
      break;
  }

  if ($errmin !== FALSE) { form_error($element, t('@element should be equal or greater than @value',
                                                  array('@value' => $errmin, '@element' => $element['#title']))); }
  if ($errmax !== FALSE) { form_error($element, t('@element should not be greater than @value',
                                                  array('@value' => $errmax, '@element' => $element['#title']))); }
}

/**
* Filter process callback.
* 
* @param string $text text to process
* @param mixed $filter filter object
* @return string processed text
*/
function _autolink_filter_process_filter($text, $filter) {
  $s            = $filter->settings;
  $min          = $s['min'];
  $max          = $s['max'];
  $max_terms    = $s['max_terms'];
  $max_words    = $s['max_words'];
  $vocs         = $s['vocabularies'];
  $excl_tags    = $s['excluded_tags'];
  $excl_words   = $s['excluded_words'];
  $excl_classes = $s['excluded_classes'];

  $processing_options   = array_filter($filter->settings['processing_options']);
  $leaves_only          = array_key_exists('leaves_only',           $processing_options);
  $selected_only        = array_key_exists('selected_only',         $processing_options);
  $use_tooltips         = array_key_exists('use_tooltips',          $processing_options);
  $use_description      = array_key_exists('use_description',       $processing_options);
  $use_synonyms         = array_key_exists('use_synonyms',          $processing_options);
  $use_virtual_synonyms = array_key_exists('use_virtual_synonyms',  $processing_options);

  if (!isset($vocs) || empty($vocs)) { return $text; }
  
  if (!isset($excl_tags)    || empty($excl_tags))     { $excl_tags            = NULL; }
  if (!isset($excl_words)   || empty($excl_words))    { $excl_words           = NULL; }
  if (!isset($excl_classes) || empty($excl_classes))  { $excl_classes         = NULL; }
  if (!isset($leaves_only))                           { $leaves_only          = NULL; }
  if (!isset($selected_only))                         { $selected_only        = NULL; }
  if (!isset($use_tooltips))                          { $use_tooltips         = NULL; }
  if (!isset($use_description))                       { $use_description      = NULL; }
  if (!isset($use_synonyms))                          { $use_synonyms         = NULL; }
  if (!isset($use_virtual_synonyms))                  { $use_virtual_synonyms = NULL; }

  if (!is_integer($max_terms))                        { settype($max_terms, 'integer'); }
  if (!is_integer($max_words))                        { settype($max_words, 'integer'); }
  if (!is_integer($min))                              { settype($min, 'integer'); }
  if (!is_integer($max))                              { settype($max, 'integer'); }

  $parser = new AutolinkFilterParser($text, $vocs,  $excl_tags, $excl_classes, $excl_words, $min, $max,
                                     $leaves_only,  $use_tooltips, $use_description, $selected_only,
                                     $use_synonyms, $use_virtual_synonyms, $max_terms, $max_words);

  $r = $parser->parse();
  $parser->clear();
  unset($vocs, $excl_tags, $excl_words, $excl_classes, $s);
  return $r;
}

/**
* Adds query autolink_sieve tag for filtering by explicite boolean marker
* (if it's not 0 and not null).
* 
* @param QueryAlterableInterface $query select query object to alter
*/
function autolink_filter_query_autolink_sieve_alter(QueryAlterableInterface $query) {
  $sieve_field = $query->getMetaData('sieve_field');
  if ($sieve_field === NULL) { return; }
  $sieve_table = 'field_data_' . $sieve_field;
  if(!db_table_exists($sieve_table)) { return; }
  $sieve_value_field = $sieve_field . '_value';
  if(!db_field_exists($sieve_table, $sieve_value_field) || !db_field_exists($sieve_table, 'entity_id')) {
    $query->condition('0', '1', '=');
    return;
  }
  $tables =& $query->getTables();
  $query
    ->join($sieve_table, 'enabled', 'enabled.entity_id = ' . $tables['taxonomy_term_data']['alias'] . '.tid');
  $query
    ->isNotNull('enabled.' . $sieve_value_field);
  $query
    ->condition('enabled.' . $sieve_value_field, 0, '<>');
}

/**
* Adds query autolink_leaves tag for using the last children of taxonomy tree.
* 
* @param QueryAlterableInterface $query select query object to alter
*/
function autolink_filter_query_autolink_leaves_alter(QueryAlterableInterface $query) {
  $tables =& $query->getTables();
  $query
    ->leftJoin('taxonomy_term_hierarchy', 'parents', 'parents.parent = ' . $tables['taxonomy_term_data']['alias'] . '.tid');
  $query
    ->isNull('parents.parent');  
  //dpm($query->__toString());
}

/**
* Adds query autolink_group_by_name tag for removing duplicated names when multiple matches occur.
* 
* @param QueryAlterableInterface $query select query object to alter
*/
function autolink_filter_query_autolink_group_by_name_alter(QueryAlterableInterface $query) {
  $tables =& $query->getTables();
  $query
    ->groupBy($tables['taxonomy_term_data']['alias'] . '.name');
}

/**
* Adds query autolink_order_by_length tag for removing duplicated names when multiple matches occur.
* 
* @param QueryAlterableInterface $query select query object to alter
*/
function autolink_filter_query_autolink_order_by_length_alter(QueryAlterableInterface $query) {
  $fn = _autolink_sql_length_clause($query);
  $tables =& $query->getTables();
  $td = $tables['taxonomy_term_data']['alias'];
  if ($query->getMetaData('use_tooltips') === TRUE && db_table_exists('field_data_field_autolink_tooltip')) {
    $query
      ->leftJoin('field_data_field_autolink_tooltip', 'ttips',
                 'ttips.entity_id = ' . $td . '.tid AND ttips.entity_type = taxonomy_term');
    $query
      ->orderBy($fn . '(ttips.field_autolink_tooltip_value)', 'DESC');
  }
  $query
    ->orderBy($fn . '(' . $td . '.description)', 'DESC');
}

/**
* Adds query taxonomy_name_length tag for filtering out names that have unwanted lengths.
* 
* @param QueryAlterableInterface $query select query object to alter
*/
function autolink_filter_query_taxonomy_name_length_alter(QueryAlterableInterface $query) {
  $fn = _autolink_sql_length_clause($query);
  $tables =& $query->getTables();
  $tname  = $tables['taxonomy_term_data']['alias'];
  $min    = $query->getMetaData('name_length_min');
  $max    = $query->getMetaData('name_length_max');
  $query
    ->where($fn . '(' . $tname . '.name) >= ' . $min);
  $query
    ->where($fn . '(' . $tname . '.name) <= ' . $max);
}

/**
* Generates proper SQL clause for testing length of a records.
* 
* @param mixed $query query object that have the 'connection' property, allowing to know the database type
* @return string SQL command for testing lengths
*/
function _autolink_sql_length_clause($query) {
  static $fn = NULL;
  if ($fn === NULL) {
    $fn = (_autolink_filter_read_property($query, 'connection')->databaseType() == 'sqlite') ? 'LENGTH' : 'CHAR_LENGTH';
  }
 return $fn; 
}

/**
 * Delete unneeded things after uninstalling.
 */
function autolink_filter_delete_all() {
  cache_clear_all('*', 'cache_filter');
}

/**
 * Reads protected properties of PHP objects using reflection.
 * 
 * @param mixed $class tested class or object
 * @param string $propertyName name of a property
 * @return mixed property value
 */
function _autolink_filter_read_property($class, $propertyName)
{
    $reflectedClass = new ReflectionClass($class);
    $property = $reflectedClass->getProperty($propertyName);
    $property->setAccessible(true);
    return $property->getValue($class);
}

/**
* Parser class
*/
class AutolinkFilterParser {
  private $src;                   // source text
  private $html;                  // HTML DOM
  private $min_length;            // minimal length of parsed word
  private $max_length;            // maximal length of parsed word
  private $leaves_only;           // use only taxonomy terms that are not parents of other terms
  private $use_tooltips;          // use tooltips
  private $use_description;       // use description when tooltip field is not available
  private $selected_only;         // require field_autolink to be true
  private $use_synonyms;          // uses synonyms
  private $changed;               // internal change marker
  private $used_terms;            // used term ID-s
  private $used_words;            // used term names (including synonyms)
  private $use_synonyms_real;     // deduced ability to use synonyms
  private $use_virtual_synonyms;  // use virtual synonyms
  private $synonyms;              // synonyms storage (used by virtual synonyms)
  private $taxonomy_cache_key;    // taxonomy cache key for current instance
  private $taxonomy_hierarchy;    // taxonomy hierarchy
  private $taxonomy_parents;      // taxonomy parents array
  private $taxonomy_roots;        // taxonomy root elements (that have no parents)
  private $callbacks;             // arrays for preg_replace method with callback method names
  private $re;                    // regular expression patterns

  private static $taxonomy        = array();  // taxonomies
  private static $long_terms_re   = array();  // taxonomy long term ID-s database
  private static $term_data       = array();  // taxonomy reverse mapping (includes tooltips)
  private static $virtual_regexes = array();  // regular expressions for virtual synonyms
  private static $chunk_size      = 48;       // number of taxonomy items to load and process at once

  function __construct($src, $vocs, $excluded_tags = '', $excluded_classes = '', $excluded_words = '', $min_length = 0,
                       $max_length = 0, $leaves_only = FALSE, $use_tooltips = TRUE, $use_description = TRUE,
                       $selected_only = FALSE, $use_synonyms = TRUE, $use_virtual_synonyms = FALSE,
                       $max_terms = 0, $max_words = 0) {

    if (is_null($vocs))                 { $vocs = array();                  }
    if (is_null($excluded_tags))        { $excluded_tags        = array();  }
    if (is_null($excluded_words))       { $excluded_words       = array();  }
    if (is_null($excluded_classes))     { $excluded_classes     = array();  }
    if (is_null($leaves_only))          { $leaves_only          = FALSE;    }
    if (is_null($selected_only))        { $selected_only        = FALSE;    }
    if (is_null($use_tooltips))         { $use_tooltips         = FALSE;    }
    if (is_null($use_description))      { $use_description      = FALSE;    }
    if (is_null($use_synonyms))         { $use_synonyms         = FALSE;    }
    if (is_null($use_virtual_synonyms)) { $use_virtual_synonyms = FALSE;    }

    if (!is_numeric($min_length) || $min_length < 0) { $min_length = 0; }
    if (!is_numeric($max_length) || $max_length < 0) { $max_length = 0; }
    if (!is_numeric($max_terms)  || $max_terms  < 0) { $max_terms  = 0; }
    if (!is_numeric($max_words)  || $max_words  < 0) { $max_words  = 0; }

    if ($min_length > 255) { $min_length = 255; }
    if ($max_length == 0 || $max_length > 255) { $max_length = 255; }
    if ($min_length > $max_length) { $min_length = $max_length; }

    $this->src                  = $src;
    $this->vocabularies         = array();
    $this->leaves_only          = $leaves_only;
    $this->min_length           = $min_length;
    $this->max_length           = $max_length;
    $this->max_terms            = $max_terms;
    $this->max_words            = $max_words;
    $this->initialize_regex();

    $this->use_tooltips         = $use_tooltips;
    $this->use_description      = $use_description;
    $this->selected_only        = $selected_only;
    $this->use_synonyms         = $use_synonyms;
    $this->excluded_tags        = $this->extract_words_as_keys(drupal_strtolower($excluded_tags));
    $this->excluded_words       = $this->extract_words($excluded_words, $this->min_length, $this->max_length);
    $this->excluded_classes     = $this->extract_words_as_keys(drupal_strtolower($excluded_classes));
    $this->use_synonyms_real    = ($this->use_synonyms && db_table_exists('field_data_synonyms_synonyms'));
    $this->use_virtual_synonyms = $use_virtual_synonyms;

    $this->callbacks->parse_fragment = array(&$this, 'parse_fragment');
    $this->callbacks->parse_sentence = array(&$this, 'parse_sentence');

    foreach($vocs as $vid => $name) {
      if ($name) { $this->vocabularies[] = $vid; }
    }

    $this->taxonomy_hierarchy = array();
    $this->taxonomy_parents = array();
    $this->synonyms = array();
    $this->load_taxonomy();
  }

  /**
   * Initializes common regular expression used by parser.
   */
  private function initialize_regex() {
    static $re_full_stop          = NULL;                       // full-stop symbols
    static $re_sentence_end       = NULL;                       // end of a sentence
    static $re_gen_word_opening   = NULL;                       // generic word that starts a sentence
    static $re_gen_words          = NULL;                       // generic words matcher
    static $re_non_word           = NULL;                       // non-word
    static $re_term_prefix_up     = NULL;                       // term-matching prefix (capital first letter)
    static $re_space              = '[\p{Zs}\s]+';              // space or repeated spaces
    static $re_letter             = '[\pL\p{Pc}\p{Pd}\pN\/]';   // single word character
    static $re_letter_uppercase   = '\p{Lu}';                   // capital word character
    static $re_non_letter         = '[^\pL\p{Pc}\p{Pd}\pN\/]';  // single non-word character
    static $re_sentence_start     = '^[\p{Zl}\p{Zp}\p{Zs}\s]*'; // beginning of a sentence

    if ($re_full_stop === NULL) {
      $re_full_stop = '[\x{00021}\x{0002E}\x{0003F}\x{00589}\x{0061F}\x{006D4}\x{00700}\x{00701}\x{00702}\x{007F9}' .
                      '\x{00964}\x{00965}\x{0104A}\x{0104B}\x{01362}\x{01367}\x{01368}\x{0166E}\x{01803}\x{01809}'  .
                      '\x{01944}\x{01945}\x{01AA8}\x{01AA9}\x{01AAA}\x{01AAB}\x{01B5A}\x{01B5B}\x{01B5E}\x{01B5F}'  .
                      '\x{01C3B}\x{01C3C}\x{01C7E}\x{01C7F}\x{0203C}\x{0203D}\x{02047}\x{02048}\x{02049}\x{02E2E}'  .
                      '\x{03002}\x{0A4FF}\x{0A60E}\x{0A60F}\x{0A6F3}\x{0A6F7}\x{0A876}\x{0A877}\x{0A8CE}\x{0A8CF}'  .
                      '\x{0A92F}\x{0A9C8}\x{0A9C9}\x{0AA5D}\x{0AA5E}\x{0AA5F}\x{0AAF0}\x{0AAF1}\x{0ABEB}\x{0FE52}'  .
                      '\x{0FE56}\x{0FE57}\x{0FF01}\x{0FF0E}\x{0FF1F}\x{0FF61}\x{11047}\x{11048}\x{110BE}\x{110BF}'  .
                      '\x{110C0}\x{110C1}\x{11141}\x{11142}\x{11143}\x{111C5}\x{111C6}\x{02026}\x{022EE}\x{022EF}'  .
                      '\x{00EAF}\x{01801}]+';
        //$re_full_stop = '\.';
    }

    // set complex static variables
    if (is_null($re_sentence_end)) { $re_sentence_end = $re_full_stop   . '[\p{Zl}\p{Zp}\p{Zs}\s]+'; }
    if (is_null($re_non_word))     { $re_non_word     = $re_non_letter  . '+'; }

    if (is_null($re_gen_word_opening)) {
      $re_gen_word_opening  =  '(?:(' . $re_sentence_start    . '|'         . $re_sentence_end . ')' .
                               '|('   . $re_non_word          . '))'        .
                               '('    . $re_letter_uppercase  . $re_letter  . '*)';
    }

    if (is_null($re_gen_words)) {
      $re_gen_words = '/(' . $re_gen_word_opening . ')(' . $re_letter . '+)('   . $re_non_word . ')/um';
    }

    if (is_null($re_term_prefix_up)) {
      $re_term_prefix_up = '(?:(' . $re_sentence_start . '|' . $re_sentence_end . ')|(' . $re_non_word . '))';
    }

    // recalculate maximum and minimum lengths for patterns that "eat" one letter
    $ucf_min_length = $this->min_length - 1;
    $ucf_max_length = $this->max_length - 1;
    if ($ucf_min_length < 0) { $ucf_min_length = 0; }
    if ($ucf_max_length < 0) { $ucf_max_length = 0; }

    // instance-specific matchers
    $re_word                    = $re_letter                        . '{' . $this->min_length  . ','  . $this->max_length  . '}';
    $re_word_titlecase          = $re_letter_uppercase . $re_letter . '{' . $ucf_min_length    . ','  . $ucf_max_length    . '}';
    $re_word_at_sentence_start  = '(' . $re_sentence_start          . '|' . $re_sentence_end   . ')(' . $re_word_titlecase . ')';

    // regular expression exports
    $this->re->words            = '/('    . $re_word_at_sentence_start . ')|(' . $re_word  . ')/um';  // words matcher
    $this->re->word_split       = '/'     . $re_non_word        . '/u';       // word-splitter matcher
    $this->re->terms_before     = '/'     . $re_term_prefix_up  . '(';        // terms catcher before
    $this->re->terms_after      = ')($|'  . $re_non_word        . ')/um';     // terms catcher final
    $this->re->space            = '/'     . $re_space           . '/um';      // space or repeated spaces
    $this->re->vsym_begin       = '(?:'   . $re_space           . '(?:';      // virt. syn. beginning
    $this->re->vsym_begin_first = ''      . $re_space           . '(?:';      // virt. syn. first beginning
    $this->re->vsym_end         = '))?';                                      // virt. syn. end
    $this->re->vsym_end_first   = ')';                                        // virt. syn. end (first)
    $this->re->vsym_end_strict  = '))';                                       // virt. syn. end (strict)
    $this->re->space_char       = $re_space;                                  // space or repeated spaces
    $this->re->vsymset_begin    = $this->re->terms_before;                    // virt. synset beginning
    $this->re->vsymset_end      = $this->re->terms_after;                     // virt. synset end
  }

  private function &taxonomy() {
    return self::$taxonomy[$this->taxonomy_cache_key];
  }

  private function &long_terms_re() {
    return self::$long_terms_re[$this->taxonomy_cache_key];
  }

  private function &term_data() {
    return self::$term_data[$this->taxonomy_cache_key];
  }

  private function &virtual_regexes() {
    return self::$virtual_regexes[$this->taxonomy_cache_key];
  }

  private function taxonomy_generate_cache_key() {
    $this->taxonomy_cache_key =
      '-' . $this->min_length         .
      '-' . $this->max_length         .
      '-' . $this->leaves_only        . '-' . $this->selected_only        .
      '-' . $this->use_tooltips       . '-' . $this->use_description      .
      '-' . $this->use_synonyms_real  . '-' . $this->use_virtual_synonyms .
      '-' . implode(':', $this->excluded_words)                           .
      '-' . implode(':', $this->vocabularies);
    return $this->taxonomy_cache_key;
  }

  private function load_taxonomy() {
    $ckey = $this->taxonomy_generate_cache_key();
    if (array_key_exists($ckey, self::$taxonomy)) { return; }

    self::$taxonomy[$ckey]      = array();
    self::$term_data[$ckey]     = array();
    self::$long_terms_re[$ckey] = array();

    if (empty($this->vocabularies)) { return; }
    if (!isset($this->synonyms)) { $this->synonyms = array(); }

    // Query for taxonomy terms.
    $query = new EntityFieldQuery;
    $query
      ->entityCondition('entity_type', 'taxonomy_term')
      ->propertyCondition('vid',  $this->vocabularies, 'IN');

    if (!empty($this->excluded_words)) {
      $query
        ->propertyCondition('name', $this->excluded_words, 'NOT IN');
    }

    $query
      ->propertyOrderBy('name')
      ->propertyOrderBy('weight');

    if ($this->use_tooltips) {
      $query
        ->addMetaData('use_tooltips', TRUE);
    }

    $query
      ->addTag('autolink_order_by_length');

    // Do not filter by length and don't group by name when using synonyms,
    // but do it later when post-processing taxonomy entities. We don't want
    // synonyms to be dropped just because main term is not meeting certain criteria.
    if (!$this->use_synonyms_real && !$this->use_virtual_synonyms) {
      $query
        ->addMetaData('name_length_min', $this->min_length)
        ->addMetaData('name_length_max', $this->max_length)
        ->addTag('taxonomy_name_length')
        ->addTag('autolink_group_by_name');
    }

    if ($this->selected_only) {
      $query
        ->addMetaData('sieve_field', 'field_autolink')
        ->addTag('autolink_sieve');
    }

    if ($this->leaves_only && !$this->use_virtual_synonyms) {
      $query
        ->addTag('autolink_leaves');
    }

    // Collect taxonomy terms.
    $tterms = $query->execute();

    if (isset($tterms['taxonomy_term'])) {
      $tidgroups = array_chunk(array_keys($tterms['taxonomy_term']), self::$chunk_size); 
      foreach($tidgroups as $tids) {
        $terms = entity_load('taxonomy_term', $tids);
        foreach($terms as $term) {
          if (isset($term->name)) {
            if ($this->use_synonyms_real || $this->use_virtual_synonyms) {
              $this->memorize_synonyms($term);
            }
            $this->memorize_term_data($term);
          }
        }
      }
    }

    // Generate virtual synonyms.
    if ($this->use_virtual_synonyms) {
      $this->load_taxonomy_hierarchy();    
    }

    
    // Create an array of regular expressions for matching terms that have many words.
    $lt_chunked = array_chunk(self::$long_terms_re[$ckey], self::$chunk_size);
    foreach ($lt_chunked as &$terms) {
      $terms = join('|', $terms);
    }
    self::$long_terms_re[$ckey] = $lt_chunked;

    unset($this->synonyms);
    unset($lt_chunked, $ucterms, $qterms);
    unset($terms, $tterms, $synonyms, $tdata, $synonym_name, $term, $query, $tip, $ckey, $tids, $name, $name_length, $tidgroups);
  }

  private function preg_make_term_name($name, $escape_spaces = TRUE) {
    $f    = drupal_substr($name, 0, 1);
    $f_uc = drupal_strtoupper($f);
    if ($f === $f_uc) {
      $name = preg_quote($name, '/');
    }
    else {
      $name = '[' . preg_quote($f . $f_uc, '/') . ']' . preg_quote(drupal_substr($name, 1));
    }
    return $escape_spaces ? preg_replace('/ /', $this->re->space_char, $name) : $name;
  }

  private function load_taxonomy_hierarchy() {
    $query = db_select('taxonomy_term_data', 't');
    $query->join('taxonomy_term_hierarchy', 'h', 'h.tid = t.tid');
    $result = $query
                ->fields('h', array('tid', 'parent'))
                ->condition('t.vid', $this->vocabularies, 'IN')
                ->execute();

     if ( $result->rowCount() <= 0 ) { unset($result); return; }
     $result = $result->fetchAll();

     foreach($result as $term) {
       if (isset($term->parent) && isset($term->tid)) {
         settype($term->parent, "integer");
         settype($term->tid, "integer");
         $tid = $term->tid;
         $par = $term->parent;
         if ($term->parent != 0) {
           $this->taxonomy_hierarchy[$tid] = $par;
         }
         else {
           $this->taxonomy_roots[] = $tid;
         }
       }
     }

    foreach ($result as $term) {
      $tid = $term->tid;
      $par = $term->parent;
      if (!array_key_exists($par, $this->taxonomy_parents)) {
        $this->taxonomy_parents[$par] = array();
      }
      $this->taxonomy_parents[$par][] = $tid;
    }

    $virtual_regs = &$this->virtual_regexes();
    foreach($this->taxonomy_roots as $id => $tid) {
      if (array_key_exists($tid, $this->taxonomy_parents)) {
        $r = $this->generate_vsym_regex($tid);
        if (empty($r)) { continue; }
        $virtual_regs[] = $r;
      }
    }

    $this->inject_vsym_terms();

    unset($tid, $par, $term, $result, $query, $r);
  }

  private function inject_vsym_terms() {
    $tdata = &$this->term_data();
    $paths = $this->get_taxonomy_paths();

    foreach ($tdata as $tid => $ent) {
      if (array_key_exists($tid, $paths)) {
        $path = array_reverse($paths[$tid]);
        $result = array();
        foreach($path as $ttid) {
           if (array_key_exists($ttid, $tdata)) {
             $names[] = $tdata[$ttid]->orig;
             if (array_key_exists($ttid, $this->synonyms)) {
               $names = array_merge($names, $this->synonyms[$ttid]);
             }
             $result[] = $names;
             unset($names);
           }
        }
        if (count($result) < 2) { continue; }
        $result = $this->cproduct($result);
        foreach ($result as $terms) {
          $virtual_term->name = implode(' ', $terms);
          $virtual_term->tid  = $ttid;
          $this->memorize_term_data($virtual_term, FALSE, FALSE);
        }
        unset($result);
      }
    }
    unset($paths);
  }

  /**
  * Gets taxonomy paths for all terms that have at least one parent.
  */
  private function get_taxonomy_paths() {
    $acc = array();
    $tdata = &$this->term_data();
    foreach ($tdata as $tid => $ent) {
      $r = $this->get_taxonomy_parents($tid, $acc);
      if (count($r) > 1) { $acc[$tid] = $r; }
    }
    unset($tdata, $tid, $ent);
    return $acc;
  }

  /**
  * Gets taxonomy paths (up to first parent) for a given term ID.
  */
  private function get_taxonomy_parents($tid, &$cache, &$results = array(), $iterations = 0) {
    if (array_key_exists($tid, $cache)) {
      //$results[] = "cache hit";
      $results = array_merge($results, $cache[$tid]);
    }
    else {
      $results[] = $tid;
      $elements = count($results);
      if (array_key_exists($tid, $this->taxonomy_hierarchy) && $iterations < 255) {
        $this->get_taxonomy_parents($this->taxonomy_hierarchy[$tid], $cache, $results, $iterations + 1);
      }
      elseif ($elements > 1) {
        $tmp = $results;
        array_shift($tmp);
        $elements--;
        while($elements > 1) {
          if (!array_key_exists($tmp[0], $cache)) {
            $cache[$tmp[0]] = $tmp;
          }
          array_shift($tmp);
          $elements--;
        }
        unset($tmp);
      }
    }
    return $results;
  }

  /**
  * Generates a regular expression for a given taxonomy subtree.
  */
  private function generate_vsym_regex($root, $level = 0, $total_length = 0) {
    $acc = '';
    $tdata = &$this->term_data();
    $syns  = &$this->synonyms;
    if (!array_key_exists($root, $tdata)) { return $acc; }

    $names = array();
    $name = $tdata[$root]->orig;
    $l = drupal_strlen($name) + $total_length;
    if ($l <= $this->max_length) { $names[] = $name; }
    if (array_key_exists($root, $syns)) {
      foreach($syns[$root] as $syn) {
        $l = drupal_strlen($syn) + $total_length;
        if ($l <= $this->max_length) { $names[] = $syn; }
      }
    }

    $c = count($names);
    if ($c <= 0) { return ''; }
    if ($level === 0) {
      foreach($names as &$name) { $name = $this->preg_make_term_name($name); }
    }
    else {
      $acc = ($level == 1) ? $this->re->vsym_begin_first : $this->re->vsym_begin;
      foreach($names as &$name) { $name = preg_replace('/ /', $this->re->space_char, preg_quote($name, '/')); }
    }
    $acc .= ($c == 1) ? $names[0] : '(?:' . implode('|', $names) . ')';

    if (array_key_exists($root, $this->taxonomy_parents)) {
      $tmp = array();
      if ($level < 255) {
        foreach($this->taxonomy_parents[$root] as $branch) {
          $tmp[] = $this->generate_vsym_regex($branch, $level + 1, $total_length + 1);
        }
      }
      $acc .= implode('|', $tmp);
      unset($tmp);
    }

    if ($level == 1) {
      $acc .= $this->re->vsym_end_first;
    }
    elseif ($level != 0) {
      $acc .= ($this->leaves_only) ? $this->re->vsym_end_strict : $this->re->vsym_end;
    }

    return $acc;
  }

  private function memorize_synonyms($term) {
    $tid = (integer) $term->tid;
    if (array_key_exists($tid, $this->synonyms)) { return; }
    $syns = $this->extract_synonyms($term);
    if (empty($syns)) { return; }
    foreach($syns as $syn) {
      $syn = preg_replace($this->re->space, ' ', $syn);
      $l = drupal_strlen($syn);
      if ($l > $this->max_length) { continue; }
      if ($this->use_virtual_synonyms) {
        #if (!array_key_exists($tid, $this->synonyms)) {
        #  $this->synonyms[$tid] = array();
        #}
        $this->synonyms[$tid][] = $syn;
      }
      elseif ($l < $this->min_length) {
        continue;
      }
      $this->memorize_term_data($term, $syn);
    }
  }

  private function memorize_term_data($term, $use_name = FALSE, $use_ltax = TRUE) {
    $tax   = &$this->taxonomy();
    $ltax  = &$this->long_terms_re();
    $tdata = &$this->term_data();

    if ($use_name === FALSE) { $use_name = $term->name; }

    // calculate lengths for data that couldn't be filtered on a database
    if ($this->use_synonyms_real || $this->use_virtual_synonyms) {
      $l = drupal_strlen($use_name);
      if (!$this->use_virtual_synonyms && $l < $this->min_length) { return; }
      if ($l > $this->max_length) { return; }
      $use_name = preg_replace($this->re->space, ' ', $use_name);
      if (!$this->use_synonyms_real && array_key_exists($use_name, $tax)) { return; }
    }
    else {
      $use_name = preg_replace($this->re->space, ' ', $use_name);
    }

    // map term name to ID in taxonomy array
    $tax[$use_name] = (integer) $term->tid;

    // memorize long term (containing spaces) in long_terms array
    if ($use_ltax && strpos($use_name, ' ') !== FALSE) {
      $ltax[] = $this->preg_make_term_name($use_name);
    }

    // update the term_data array if we're going to need some data indexed by term ID
    if ($this->use_tooltips || $this->use_virtual_synonyms) {
      if (!array_key_exists($term->tid, $tdata)) {
        // get tooltip text
        if ($this->use_tooltips) {
          if (empty($term->autolink_tooltip) && $this->use_description) {
             $ent->tip = drupal_substr($term->description, 0, 255);
           }
           else {
             $ent->tip = $term->autolink_tooltip;
           }
        }
        $ent->term = $use_name;
        $ent->orig = $term->name;
        $tdata[$term->tid] = $ent;
      }
    }

    unset($l, $term, $use_name, $orign, $tax, $ltax, $tdata, $syns, $ent, $syn);
  }

  private function extract_synonyms($term) {
    $r = array();
    if (isset($term->synonyms_synonyms) &&
        isset($term->synonyms_synonyms['und'])) { 
      foreach($term->synonyms_synonyms['und'] as $s) {
        if (isset($s['safe_value'])) {
          $r[] = $s['safe_value'];
        }
        elseif (isset($s['value'])) {
          $r[] = $s['value'];
        }
      }
    }
    return $r;
  }

  private function extract_words($text, $minlength = 0, $maxlength = 0) {
    if (($minlength + $maxlength) === 0) {
      return array_filter(preg_split($this->re->word_split, $text));
    }
    else {
      $r = $this->extract_words($text);
      foreach ($r as $k => $word) {
        $l = drupal_strlen($word);
        if ($l < $minlength || $l > $maxlength) {
          unset($r[$k]);
        }
      }
      unset($k, $word);
      return $r;
    }
  }

  private function extract_words_as_keys($text, $minl = 0, $maxl = 0) {
    return array_flip($this->extract_words($text, $minl, $maxl));
  }

  private function extract_words_from_text($text) {
    return array_flip($this->extract_words($text), $this->min_length, $this->max_length);
  }

  private function in_excluded_tag(& $el) {
    if (!isset($el->parent)) { return FALSE; }
    $p = & $el->parent;

    if ($p->hasAttribute('class')) {
      $classes = array_flip(preg_split('/\s/', $p->class));
      if (array_intersect_key($classes, $this->excluded_classes)) {
        unset($classes);
        return TRUE;
      }
      unset($classes);
    }

    if (array_key_exists($p->tag, $this->excluded_tags)) { return TRUE; }

    return $this->in_excluded_tag($p);
  }

  public function parse() {
    $tax  = &$this->taxonomy();
    $ltax = &$this->long_terms_re();
    $vtax = &$this->virtual_regexes();
    $this->changed = FALSE;
    $this->used_terms = array();
    $this->used_words = array();
    $this->html = new simple_html_dom();
    $this->html->load($this->src, true, false);

    // Step 0 - parse virtual synonyms.
    if ($this->use_virtual_synonyms) {
      foreach ($this->html->find('text') as $fragment) {
        if ($this->in_excluded_tag($fragment)) { continue; }
        foreach ($vtax as $terms_regex) {
          $rgx = $this->re->vsymset_begin . $terms_regex . $this->re->vsymset_end;
          $fragment->innertext = preg_replace_callback($rgx, $this->callbacks->parse_sentence, $fragment->innertext);
        }
      }
      if ($this->changed) { $this->html->load($this->html->save()); }
    }

    // Step I - parse terms that have multiple words.
    foreach ($this->html->find('text') as $fragment) {
      if ($this->in_excluded_tag($fragment)) { continue; }
      foreach ($ltax as $terms_regex) {
        $rgx = $this->re->terms_before . $terms_regex . $this->re->terms_after;
        $fragment->innertext = preg_replace_callback($rgx, $this->callbacks->parse_sentence, $fragment->innertext);
      }
    }

    if ($this->changed) { $this->html->load($this->html->save()); }

    // Step II - parse terms that are single words.
    foreach ($this->html->find('text') as $fragment) {
      if (!$this->in_excluded_tag($fragment)) {
        $fragment->innertext = preg_replace_callback($this->re->words, $this->callbacks->parse_fragment, $fragment->innertext);
      }
    }

    // Step III - generate tooltips.
    if ($this->changed) {
      $ttips = $this->use_tooltips ? $this->generate_tooltips() : '';
      $out = $this->html->outertext . $ttips;
      unset($ttips);
    }
    else {
      $out = $this->src;
    }
    $this->html->clear();
    unset($this->html, $this->used_terms, $this->used_words, $fragment, $vid, $vname, $term, $tax, $ltax, $rgx, $terms_regex);
    return $out;
  }

  private function parse_fragment($matches) {
    if (!isset($matches[0])) { return ''; }
    $tax  = &$this->taxonomy();
    $orig = $matches[0];
    $word = '';
    $pref = '';

    // title-case word at the beginning of a sentence
    if (!empty($matches[3])) {
      $word = $matches[3];
      $pref = $matches[2];
      $lc = $this->lcfirst($word);
      if (array_key_exists($lc, $tax)) {
        return $pref . $this->generate_link($word, $lc);
      }
    } // word inside of a sentence
    elseif (!empty($matches[4])) {
      $word = $matches[4];
    }
    else {
      return $orig;
    }

    if (array_key_exists($word, $tax)) {
      return $pref . $this->generate_link($word);
    }

    return $orig;
  }

  private function parse_sentence($matches) {
    if (!isset($matches[0])) { return ''; }
    $tax  = &$this->taxonomy();
    $orig = $matches[0];
    $pref = $matches[1] . $matches[2];
    $word = $matches[3];
    $suff = $matches[4];
    $term = $word;

    if (!array_key_exists($term, $tax)) {
      $term = preg_replace($this->re->space, ' ', $term);
    }

    if (!array_key_exists($term, $tax)) {
      if (!empty($matches[2])) {         // in the middle of a sentence
        return $orig;
      }
      else {
        $term = $this->change_first_case($term);
        if (!array_key_exists($term, $tax)) {
          return $orig;
        }
      }
    }

    if ($term !== $word) { $term = NULL; }
    return $pref . $this->generate_link($word, $term) . $suff;
  }

  private function ucfirst($name) {
    return drupal_strtoupper(drupal_substr($name, 0, 1)) .
           drupal_substr($name, 1);
  }

  private function lcfirst($name) {
    return drupal_strtolower(drupal_substr($name, 0, 1)) .
           drupal_substr($name, 1);
  }

  private function change_first_case($name) {
    $fl = drupal_substr($name, 0, 1);
    return ($fl == drupal_strtolower($fl)) ? $this->ucfirst($name) : $this->lcfirst($name);
  }

  private function generate_link($word, $orig = NULL) {
    $tax = &$this->taxonomy();
    if (is_null($orig)) { $orig = $word; }
    $tid = $tax[$orig];

    $this->used_terms[$tid]  = !array_key_exists($tid,  $this->used_terms) ? 1 : $this->used_terms[$tid]  + 1;
    $this->used_words[$orig] = !array_key_exists($orig, $this->used_words) ? 1 : $this->used_words[$orig] + 1;
    
    if ($this->max_terms > 0 && $this->used_terms[$tid]  > $this->max_terms) { return $word; }    
    if ($this->max_words > 0 && $this->used_words[$orig] > $this->max_words) { return $word; }

    $tips = &$this->term_data();
    $tiprefstring = '';
    if ($this->use_tooltips && array_key_exists($tid, $tips)) {
      if (!empty($tips[$tid]->tip)) {
        $tiprefstring = ' id="term-ref-' . $tid . '"';
      }
    }

    if (!$this->changed) { $this->changed = TRUE; }

    return '<a href="' . url('taxonomy/term/' . $tid) . '" title="' . $this->ucfirst($orig) . '" ' .
           'class="taxonomy-autolink"' . $tiprefstring . '>' . $word . '</a>';
  }

  private function generate_tooltips() {
    $tips = &$this->term_data();
    $r  = "\n" . '<!-- tooltips -->' . "\n";
    $r .= '<div id="tooltips-container" style="display:none;">' . "\n";
    $r .= '<p>Tooltips:</p>' . "\n";
    foreach($this->used_terms as $tid => $count) {
      if (array_key_exists($tid, $tips)) {
        $tip = $tips[$tid];
        if (!empty($tip->tip)) {
          $r  .= '<div id="term-def-' . $tid . '">';
          $r  .= '<h3 class="term-name">' . $this->ucfirst($tip->orig) . '</h3>'  . "\n";
          $r  .= '<div class="term-def">' . $tip->tip                  . '</div>' . "\n";
          $r  .= '</div>' . "\n";
        }
      }
    }
    $r .= "</div>\n<!--eof tooltips -->\n";
    unset($tid, $tips, $count);
    return $r;
  }

  private function cproduct($arrays, $i = 0) {
      if (!isset($arrays[$i]))      { return array();     }
      if ($i == count($arrays) - 1) { return $arrays[$i]; }

      $tmp = $this->cproduct($arrays, $i + 1);
      $result = array();
      foreach ($arrays[$i] as $v) {
        foreach ($tmp as $t) {
          $result[] = is_array($t) ? array_merge(array($v), $t) : array($v, $t);
        }
      }
      return $result;
  }

  public function clear() {
    unset($this->src, $this->query, $this->used_terms, $this->used_words);
  }
}

//todo: leaves-only handling in virtual synonyms
//todo: check if lengths are checked when adding virtual synonyms as terms
