<?php

/**
* @file
* autolink_filter.module
* 
* @author PaweÅ‚ Wilk
* @link http://github.com/siefca/autolink_filter
*
* Provides automatic linking filter for input formats.
*/

/**
* Implements hook_init().
*/
function autolink_filter_init() {
  $path = drupal_get_path('module', 'autolink_filter');
}

/**
* Implements hook_filter_info().
*/
function autolink_filter_filter_info() {
  $filters          = array();
  $excluded_tags    = 'a link pre h1 h2 h3 h4 h5 h6 h7 code pre address';
  $excluded_classes = 'nolink caption';
  $excluded_words   = 'or of for while because and but no yes though they i you he she it since are were have had been m very' . 
                      'less also to too then when off over';
  $filters['autolink_filter'] = array(
    'title'             => t('Automatically link keywords from vocabularies'),
    'process callback'  => '_autolink_filter_process_filter',
    'settings callback' => '_autolink_filter_settings',
    'weight'            => 50,
    'default settings'  => array(
      'excluded_tags'   => $excluded_tags,
      'excluded_classes'=> $excluded_classes,
      'excluded_words'  => $excluded_words,
      'vocabularies'    => _autolink_filter_vocab_array(),
      'processing_options' => array('use_tooltips', 'use_synonyms'),
      'min'             => 2,
      'max'             => 32,
    ),
  );
  return $filters;
}

/**
* Renders processing options array.
*/
function _autolink_filter_processing_options_array() {
  return array(
    'leaves_only'   => t('Only use terms that are the last children (leaves) of a taxonomy tree.'),
    'selected_only' => t('Only use terms that have <code>field_autolink</code> boolean field set.'),
    'use_tooltips'  => t('Generate tooltips (uses <code>field_autolink_tooltip</code> text fields from taxonomy terms).'),
    'use_synonyms'  => t('Use taxonomy synonyms if available.'),
  );
}

/**
* Gets vocabularies as an array.
*/
function _autolink_filter_vocab_array() {
  $checklist_vocab_array = array();
  $vocabulary = taxonomy_get_vocabularies();
  foreach ($vocabulary as $item) {
    $checklist_vocab_array[$item->vid] = $item->name;
  }
  unset($item);
  return $checklist_vocab_array;
}

/**
 * Settings callback.
 */
function _autolink_filter_settings($form, &$form_state, $filter, $format, $defaults, $filters) {
  $filter->settings += $defaults;
  return array(
    'reminder' => array(
      '#type'   => 'item',
      '#title'  => t('In most cases, Autolink Filter should be the <em>last</em> filter in the &ldquo;Filter processing order&rdquo; list. It is also recommended to run &ldquo;@htmlcorrector_name&rdquo; after this filter, when tooltips are in use.', array('@htmlcorrector_name' => t('Correct faulty and chopped off HTML'))),
      '#weight' => -20,
    ),
    'processing_options' => array(
      '#type'           => 'checkboxes',
      '#title'          => t('Processing options'),
      '#position'       => 'left',
      '#options'        => _autolink_filter_processing_options_array(),
      '#default_value'  => $filter->settings['processing_options'],
      '#weight'         => -5,
      '#description'    => t('Select desirable processing options.'),
    ),
    'excluded_tags' => array(
      '#type'           => 'textfield',
      '#title'          => t('HTML tags excluded from processing'),
      '#default_value'  => $filter->settings['excluded_tags'],
      '#size'           => '63',
      '#weight'         => -10,
      '#description'    => t('Enter HTML tag names (separated by spaces and/or commas) for which a content (contained within) will not be processed.'),
    ),
    'excluded_classes' => array(
      '#type'           => 'textfield',
      '#title'          => t('HTML classes excluded from processing'),
      '#default_value'  => $filter->settings['excluded_classes'],
      '#size'           => '63',
      '#weight'         => -8,
      '#description'    => t('Enter HTML class attribute values (separated by spaces and/or commas) for which a content (contained within) will not be processed.'),
    ),
    'excluded_words' => array(
      '#type'           => 'textfield',
      '#title'          => t('Words excluded from processing'),
      '#default_value'  => $filter->settings['excluded_words'],
      '#size'           => '63',
      '#weight'         => -7,
      '#description'    => t('Enter words (separated by spaces and/or commas) which won\'t be processed.'),
    ),
    'min'               => array(
      '#type'           => 'textfield',
      '#title'          => t('Minimum length of a word'),
      '#default_value'  => $filter->settings['min'],
      '#size'           => '3',
      '#maxlength'      => '4',
      '#element_validate' => array('_autolink_filter_length_validate'),
      '#weight'         => -4,
      '#description'    => t('The minimum acceptable number of letters in a word to be processed (@min to @max)',
                            array('@min' => 0, '@max' => 32)),
    ),
      'max'             => array(
      '#type'           => 'textfield',
      '#title'          => t('Maximum length of a word'),
      '#default_value'  => $filter->settings['max'],
      '#size'           => '3',
      '#maxlength'      => '4',
      '#element_validate' => array('_autolink_filter_length_validate'),
      '#weight'         => -2,
      '#description'    => t('The maximum acceptable number of letters in a word to be processed (@min to @max)',
                            array('@min' => 1, '@max' => 32)),
    ),
    'vocabularies' => array(
      '#type'           => 'checkboxes',
      '#title'          => t('Vocabularies'),
      '#position'       => 'left',
      '#options'        => _autolink_filter_vocab_array(),
      '#default_value'  => $filter->settings['vocabularies'],
      '#weight'         => 0,
      '#description'    => t('Select taxonomy vocabularies used to automatically link keywords.'),
    )
  );
}

/**
 * Element validate callback for fields that contain lengths.
 */
function _autolink_filter_length_validate($element, $form_state, $form) {
  if (!empty($element['#value']) && !is_numeric($element['#value'])) {
    form_error($element, $element['#title'] . ' ' . t('should only contain numbers.'));
  }

  settype($element['#value'], 'integer');
  $val = $element['#value'];
  $errv = FALSE;
  if ($val > 32) {
    $errv = 'should not be greater than 32';
  }
  else {
    switch(end($element['#array_parents'])) {
      case 'min':
        if ($val < 0) { $errv = 0; }
        break;
      case 'max':
        if ($val < 1) { $errv = 1; }
        break;
    }
    if ($errv !== FALSE) { $errv = t('should be equal or greater than') . ' ' . $errv; }
  }
  if ($errv !== FALSE) { form_error($element, $element['#title'] . ' ' . $errv . '.'); }
}

/**
* Filter process callback.
*/
function _autolink_filter_process_filter($text, $filter) {
  $s                  = $filter->settings;
  $min                = $s['min'];
  $max                = $s['max'];
  $vocs               = $s['vocabularies'];
  $excl_tags          = $s['excluded_tags'];
  $excl_words         = $s['excluded_words'];
  $excl_classes       = $s['excluded_classes'];

  $processing_options = array_filter($filter->settings['processing_options']);
  $leaves_only        = array_key_exists('leaves_only',   $processing_options);
  $selected_only      = array_key_exists('selected_only', $processing_options);
  $use_tooltips       = array_key_exists('use_tooltips',  $processing_options);
  $use_synonyms       = array_key_exists('use_synonyms',  $processing_options);

  if (!isset($vocs) || empty($vocs)) { return $text; }
  if (!isset($excl_tags)    || empty($excl_tags))     { $excl_tags     = NULL; }
  if (!isset($excl_words)   || empty($excl_words))    { $excl_words    = NULL; }
  if (!isset($excl_classes) || empty($excl_classes))  { $excl_classes  = NULL; }
  if (!isset($leaves_only))                           { $leaves_only   = NULL; }
  if (!isset($selected_only))                         { $selected_only = NULL; }
  if (!isset($use_tooltips))                          { $use_tooltips  = NULL; }
  if (!isset($use_synonyms))                          { $use_synonyms  = NULL; }
  if (!is_integer($min))                              { settype($min, 'integer'); }
  if (!is_integer($max))                              { settype($max, 'integer'); }

  $parser = new AutolinkFilterParser($text, $vocs, $excl_tags, $excl_classes, $excl_words, $min, $max,
                                     $leaves_only, $use_tooltips, $selected_only, $use_synonyms);

  $r = $parser->parse();
  $parser->clear();
  unset($vocs, $excl_tags, $excl_words, $excl_classes, $s);
  return $r;
}

/**
* Adds query autolink_sieve tag for filtering by explicite boolean marker
* (if it's not 0 and not null).
*/
function autolink_filter_query_autolink_sieve_alter(QueryAlterableInterface $query) {
  $sieve_field = $query->getMetaData('sieve_field');
  if ($sieve_field === NULL) { return; }
  $sieve_table = 'field_data_' . $sieve_field;
  if(!db_table_exists($sieve_table)) { return; }
  $sieve_value_field = $sieve_field . '_value';
  if(!db_field_exists($sieve_table, $sieve_value_field) || !db_field_exists($sieve_table, 'entity_id')) {
    $query->condition('0', '1', '=');
    return;
  }
  $tables =& $query->getTables();
  $query
    ->join($sieve_table, 'enabled', 'enabled.entity_id = ' . $tables['taxonomy_term_data']['alias'] . '.tid');
  $query
    ->isNotNull('enabled.' . $sieve_value_field);
  $query
    ->condition('enabled.' . $sieve_value_field, 0, '<>');
}

/**
* Adds query autolink_leaves tag for using the last children of taxonomy tree.
*/
function autolink_filter_query_autolink_leaves_alter(QueryAlterableInterface $query) {
  $tables =& $query->getTables();
  $query
    ->leftJoin('taxonomy_term_hierarchy', 'parents', 'parents.parent = ' . $tables['taxonomy_term_data']['alias'] . '.tid');
  $query
    ->isNull('parents.parent');  
  //dpm($query->__toString());
}

/**
* Adds query autolink_group_by_name tag for removing duplicated names when multiple matches occur.
*/
function autolink_filter_query_autolink_group_by_name_alter(QueryAlterableInterface $query) {
  $tables =& $query->getTables();
  $query
    ->groupBy($tables['taxonomy_term_data']['alias'] . '.name');
}

/**
* Adds query autolink_order_by_length tag for removing duplicated names when multiple matches occur.
*/
function autolink_filter_query_autolink_order_by_length_alter(QueryAlterableInterface $query) {
  $fn = _autolink_sql_length_clause($query);
  $tables =& $query->getTables();
  $td = $tables['taxonomy_term_data']['alias'];
  if ($query->getMetaData('use_tooltips') === TRUE && db_table_exists('field_data_field_autolink_tooltip')) {
    $query
      ->leftJoin('field_data_field_autolink_tooltip', 'ttips',
                 'ttips.entity_id = ' . $td . '.tid AND ttips.entity_type = taxonomy_term');
    $query
      ->orderBy($fn . '(ttips.field_autolink_tooltip_value)', 'DESC');
  }
  $query
    ->orderBy($fn . '(' . $td . '.description)', 'DESC');
}

/**
* Adds query taxonomy_name_length tag for filtering out names that have unwanted lengths.
*/
function autolink_filter_query_taxonomy_name_length_alter(QueryAlterableInterface $query) {
  $fn = _autolink_sql_length_clause($query);
  $tables =& $query->getTables();
  $tname = $tables['taxonomy_term_data']['alias'];
  $min = $query->getMetaData('name_length_min');
  $max = $query->getMetaData('name_length_max');
  $query
    ->where($fn . '(' . $tname . '.name) >= ' . $min);
  $query
    ->where($fn . '(' . $tname . '.name) <= ' . $max);
}

function _autolink_sql_length_clause($query) {
  static $fn = NULL;
  if ($fn === NULL) {
    $fn = (_autolink_filter_read_property($query, 'connection')->databaseType() == 'sqlite') ? 'LENGTH' : 'CHAR_LENGTH';
  }
 return $fn; 
}

/**
 * Delete unneeded things after uninstalling.
 */
function autolink_filter_delete_all() {
  cache_clear_all('*', 'cache_filter');
}

function _autolink_filter_read_property($class, $propertyName)
{
    $reflectedClass = new ReflectionClass($class);
    $property = $reflectedClass->getProperty($propertyName);
    $property->setAccessible(true);
    return $property->getValue($class);
}

/**
* Parser class
*/
class AutolinkFilterParser {
  private $src;               // source text
  private $html;              // HTML DOM
  private $min_length;        // minimal length of parsed word
  private $max_length;        // maximal length of parsed word
  private $leaves_only;       // use only taxonomy terms that are not parents of other terms
  private $use_tooltips;      // use tooltips
  private $selected_only;     // require field_autolink to be true
  private $use_synonyms;      // uses synonyms
  private $changed;           // internal change marker
  private $used_tips;         // used term ID-s
  private $use_synonyms_real; // deduced ability to use synonyms
  private $taxonomy_cache_key;// taxonomy cache key for current instance
  private $callbacks;         // arrays for preg_replace method with callback method names
  private $re;                // regular expression patterns

  private static $taxonomy      = array();  // taxonomies
  private static $long_terms    = array();  // taxonomy long term ID-s database
  private static $tooltips      = array();  // taxonomy tooltips
  private static $taxonomy_sum  = '';       // taxonomy sum (for caching)
  private static $chunk_size    = 28;       // number of taxonomy items to load and process at once

  function __construct($src, $vocs, $excluded_tags = '', $excluded_classes = '', $excluded_words = '', $min_length = 0,
                       $max_length = 0, $leaves_only = FALSE, $use_tooltips = TRUE, $selected_only = FALSE,
                       $use_synonyms = 1) {

    if (is_null($vocs))             { $vocs = array();              }
    if (is_null($excluded_tags))    { $excluded_tags    = array();  }
    if (is_null($excluded_words))   { $excluded_words   = array();  }
    if (is_null($excluded_classes)) { $excluded_classes = array();  }
    if (is_null($leaves_only))      { $leaves_only      = FALSE;    }
    if (is_null($selected_only))    { $selected_only    = FALSE;    }
    if (is_null($use_tooltips))     { $use_tooltips     = FALSE;    }
    if (is_null($use_synonyms))     { $use_synonyms     = FALSE;    }

    if (!is_numeric($min_length) || $min_length < 0)    { $min_length = 0;  }
    if (!is_numeric($max_length) || $max_length < 0)    { $max_length = 0;  }
    if ($min_length > 255)  { $min_length = 255; }
    if ($max_length == 0 || $max_length > 255) { $max_length = 255; }
    if ($min_length > $max_length) { $min_length = $max_length; }

    $this->src                = $src;
    $this->vocabularies       = array();
    $this->leaves_only        = $leaves_only;
    $this->min_length         = $min_length;
    $this->max_length         = $max_length;
    $this->initialize_regex();

    $this->use_tooltips       = $use_tooltips;
    $this->selected_only      = $selected_only;
    $this->use_synonyms       = $use_synonyms;
    $this->excluded_tags      = $this->extract_words_as_keys(drupal_strtolower($excluded_tags));
    $this->excluded_words     = $this->extract_words($excluded_words, $this->min_length, $this->max_length);
    $this->excluded_classes   = $this->extract_words_as_keys(drupal_strtolower($excluded_classes));
    $this->use_synonyms_real  = ($this->use_synonyms && db_table_exists('field_data_synonyms_synonyms'));

    $this->callbacks->parse_fragment = array(&$this, 'parse_fragment');
    $this->callbacks->parse_sentence = array(&$this, 'parse_sentence');

    foreach($vocs as $vid => $name) {
      if ($name) { $this->vocabularies[] = $vid; }
    }

    $this->load_taxonomy();
  }

  private function initialize_regex() {
    static $re_full_stop                  = NULL;                             // full-stop symbols
    static $re_sentence_end               = NULL;                             // end of a sentence
    static $re_gen_word_first_in_sentence = NULL;                             // generic word that starts a sentence
    static $re_gen_words                  = NULL;                             // generic words matcher
    static $re_non_word                   = NULL;                             // non-word
    static $re_term_prefix_uppercased     = NULL;                             // term-matching prefix (capital first letter)
    static $re_letter                     = '[\pL\p{Pc}\p{Pd}\pN\/]';         // single word character
    static $re_letter_uppercase           = '\p{Lu}';                         // capital word character
    static $re_non_letter                 = '[^\pL\p{Pc}\p{Pd}\pN\/]';        // single non-word character
    static $re_sentence_start             = '^[\p{Zl}\p{Zp}\p{Zs}]*';         // beginning of a sentence
    

    if ($re_full_stop === NULL) {
      $re_full_stop = '[\x{00021}\x{0002E}\x{0003F}\x{00589}\x{0061F}\x{006D4}\x{00700}\x{00701}\x{00702}\x{007F9}' .
                      '\x{00964}\x{00965}\x{0104A}\x{0104B}\x{01362}\x{01367}\x{01368}\x{0166E}\x{01803}\x{01809}' .
                      '\x{01944}\x{01945}\x{01AA8}\x{01AA9}\x{01AAA}\x{01AAB}\x{01B5A}\x{01B5B}\x{01B5E}\x{01B5F}' .
                      '\x{01C3B}\x{01C3C}\x{01C7E}\x{01C7F}\x{0203C}\x{0203D}\x{02047}\x{02048}\x{02049}\x{02E2E}' .
                      '\x{03002}\x{0A4FF}\x{0A60E}\x{0A60F}\x{0A6F3}\x{0A6F7}\x{0A876}\x{0A877}\x{0A8CE}\x{0A8CF}' .
                      '\x{0A92F}\x{0A9C8}\x{0A9C9}\x{0AA5D}\x{0AA5E}\x{0AA5F}\x{0AAF0}\x{0AAF1}\x{0ABEB}\x{0FE52}' .
                      '\x{0FE56}\x{0FE57}\x{0FF01}\x{0FF0E}\x{0FF1F}\x{0FF61}\x{11047}\x{11048}\x{110BE}\x{110BF}' .
                      '\x{110C0}\x{110C1}\x{11141}\x{11142}\x{11143}\x{111C5}\x{111C6}\x{02026}\x{022EE}\x{022EF}' .
                      '\x{00EAF}\x{01801}]+';
        //$re_full_stop = '\.';
    }

    if ($re_sentence_end === NULL) {
      $re_sentence_end = $re_full_stop . '[\p{Zl}\p{Zp}\p{Zs}]+';
    }
    
    if ($re_gen_word_first_in_sentence === NULL) {
      $re_gen_word_first_in_sentence =  '(' . $re_sentence_start . '|' . $re_sentence_end . ')' .
                                        '(' . $re_letter_uppercase . $re_letter . '*)';
    }

    if ($re_gen_words === NULL) {
      $re_gen_words = '/(' . $re_gen_word_first_in_sentence. ')|(' . $re_letter . '+)/u';
    }

    if ($re_non_word === NULL) {
      $re_non_word = $re_non_letter . '+';
    }

    if ($re_term_prefix_uppercased === NULL) {
      $re_term_prefix_uppercased  = '(' . $re_sentence_start  . '|' . $re_sentence_end . ')';
    }

    // recalculate maximum and minimum lengths for patterns that "eat" one letter
    $ucf_min_length  = $this->min_length - 1;
    $ucf_max_length  = $this->max_length - 1;
    if ($ucf_min_length < 0) { $ucf_min_length = 0; }
    if ($ucf_max_length < 0) { $ucf_max_length = 0; }

    // instance-specific matchers
    $re_word                    = $re_letter                        . '{' . $this->min_length   . ',' . $this->max_length . '}';
    $re_word_titlecase          = $re_letter_uppercase . $re_letter . '{' . $ucf_min_length     . ',' . $ucf_max_length   . '}';
    $re_word_at_sentence_start  = '(' . $re_sentence_start  . '|' . $re_sentence_end . ')(' . $re_word_titlecase . ')';

    // regular expression exports
    $this->re->words        = '/('   . $re_word_at_sentence_start . ')|(' . $re_word    . ')/u';  // words matcher
    $this->re->word_split   = '/'    . $re_non_word . '/u';                                       // word-splitter matcher
    $this->re->terms_before = '/('   . $re_term_prefix_uppercased . '(';                          // terms catcher before
    $this->re->terms_middle = '))|(('. $re_non_word . ')(';                                       // terms catcher second
    $this->re->terms_after  = ')('   . $re_non_word .  '))/u';                                    // terms catcher final
  }

  private function &taxonomy() {
    return self::$taxonomy[$this->taxonomy_cache_key];
  }

  private function &long_terms() {
    return self::$long_terms[$this->taxonomy_cache_key];
  }

  private function &tooltips() {
    return self::$tooltips[$this->taxonomy_cache_key];
  }

  private function taxonomy_generate_cache_key() {
    $this->taxonomy_cache_key =
      '-' . $this->min_length    .
      '-' . $this->max_length    . 
      '-' . $this->leaves_only   . '-' . $this->selected_only      .
      '-' . $this->use_tooltips  . '-' . $this->use_synonyms_real  .
      '-' . implode(':', $this->excluded_words) .
      '-' . implode(':', $this->vocabularies);
    return $this->taxonomy_cache_key;
  }

  private function load_taxonomy() {
    $ckey = $this->taxonomy_generate_cache_key();
    if (array_key_exists($ckey, self::$taxonomy)) { return; }
    self::$taxonomy[$ckey]    = array();
    self::$tooltips[$ckey]    = array();
    self::$long_terms[$ckey]  = array();

    // Query for taxonomy terms.
    $query = new EntityFieldQuery;
    $query
      ->entityCondition('entity_type', 'taxonomy_term')
      ->propertyCondition('vid',  $this->vocabularies, 'IN')
      ->propertyCondition('name', $this->excluded_words, 'NOT IN')
      ->propertyOrderBy('name')
      ->propertyOrderBy('weight')
      ->addMetaData('use_tooltips', TRUE)
      ->addTag('autolink_order_by_length');

    // Do not filter lengths and don't group by name when using synonyms,
    // but do it later when post-processing taxonomy entities. We don't want
    // synonyms to be dropped just because main term is not meeting certain criteria.
    if (!$this->use_synonyms_real) {
      $query
        ->addMetaData('name_length_min', $this->min_length)
        ->addMetaData('name_length_max', $this->max_length)
        ->addTag('taxonomy_name_length')
        ->addTag('autolink_group_by_name');
    }

    if ($this->selected_only) {
      $query
        ->addMetaData('sieve_field', 'field_autolink')
        ->addTag('autolink_sieve');
    }

    if ($this->leaves_only) {
      $query
        ->addTag('autolink_leaves');
    }

    // Collect taxonomy terms.
    $synonyms = array();
    $needed_terms = array();
    $tterms = $query->execute();
    if (isset($tterms['taxonomy_term'])) {
      $tidgroups = array_chunk(array_keys($tterms['taxonomy_term']), self::$chunk_size); 
      foreach($tidgroups as $tids) {
        $terms = entity_load('taxonomy_term', $tids);
        foreach($terms as $term) {
          if (isset($term->name)) {
            if ($this->use_synonyms_real) {
              $synonyms = $this->extract_synonyms($term);
              foreach($synonyms as $synonym_name) {      
                $this->memorize_term_data($term, $synonym_name);
              }
            }
            $this->memorize_term_data($term);
          }
        }
      }
    }

    // Create an array of regular expressions for matching terms that have many words.
    $lt_chunked = array_chunk(self::$long_terms[$ckey], self::$chunk_size);
    foreach($lt_chunked as &$terms) {
      $ucterms = array();
      foreach ($terms as $term) { $ucterms[] = $this->ucfirst($term); }
      $terms = array(join('|', $ucterms), join('|', $terms));
    }
    self::$long_terms[$ckey] = $lt_chunked;

    unset($lt_chunked, $ucterms);
    unset($terms, $tterms, $synonyms, $synonym_name, $term, $query, $tip, $ckey, $tids, $name, $name_length, $tidgroups);
  }

  private function memorize_term_data($term, $use_name = FALSE) {
    $tax  = &$this->taxonomy();
    $ltax = &$this->long_terms();
    $tips = &$this->tooltips();
    if ($use_name === FALSE) { $use_name = $term->name; }
    if ($this->use_synonyms_real) {
      $l = drupal_strlen($use_name);
      if ($l < $this->min_length || $l > $this->max_length) { return; }
      if (array_key_exists($use_name, $tax)) { return; }
    }
    $tax[$use_name] = $term->tid;
    if (strpos($use_name, ' ')) { $ltax[] = $use_name; }
    if ($this->use_tooltips && isset($term->autolink_tooltip)) {
      if (!array_key_exists($term->tid, $tips)) {
        $tips[$term->tid] = array('tip' => $term->autolink_tooltip, 'orig' => $term->name);
      }
    }
    unset($l, $term, $use_name, $orign, $tax, $ltax, $tips);
  }

  private function extract_synonyms($term) {
    $r = array();
    if (isset($term->synonyms_synonyms) && isset($term->synonyms_synonyms['und'])) { 
      foreach($term->synonyms_synonyms['und'] as $s) {
        if (isset($s['safe_value'])) {
          $r[] = $s['safe_value'];
        }
        elseif (isset($s['value'])) {
          $r[] = $s['value'];
        }
      }
    }
    return $r;
  }

  private function extract_words($text, $minlength = 0, $maxlength = 0) {
    if (($minlength + $maxlength) === 0) {
      return array_filter(preg_split($this->re->word_split, $text));
    }
    else {
      $r = $this->extract_words($text);
      foreach ($r as $k => $word) {
        $l = drupal_strlen($word);
        if ($l < $minlength || $l > $maxlength) {
          unset($r[$k]);
        }
      }
      unset($k, $word);
      return $r;
    }
  }

  private function extract_words_as_keys($text, $minl = 0, $maxl = 0) {
    return array_flip($this->extract_words($text, $minl, $maxl));
  }

  private function extract_words_from_text($text) {
    return array_flip($this->extract_words($text), $this->min_length, $this->max_length);
  }

  private function in_excluded_tag(& $el) {
    if (!isset($el->parent)) { return FALSE; }
    $p = & $el->parent;

    if ($p->hasAttribute('class')) {
      $classes = array_flip(preg_split('/\s/', $p->class));
      if (array_intersect_key($classes, $this->excluded_classes)) {
        unset($classes);
        return TRUE;
      }
      unset($classes);
    }

    if (array_key_exists($p->tag, $this->excluded_tags)) { return TRUE; }

    return $this->in_excluded_tag($p);
  }

  public function parse() {
    $tax  = &$this->taxonomy();
    $ltax = &$this->long_terms();
    $this->changed = FALSE;
    $this->used_tips = array();
    $this->html = new simple_html_dom();
    $this->html->load($this->src, true, false);

    
    // Step I - parse terms that have multiple words.
    foreach ($this->html->find('text') as $fragment) {
      if ($this->in_excluded_tag($fragment)) { continue; }
      foreach ($ltax as $terms_regex) {
          $rgx = $this->re->terms_before . $terms_regex[0] .
                 $this->re->terms_middle . $terms_regex[1] .
                 $this->re->terms_after;
          $fragment->innertext = preg_replace_callback($rgx, $this->callbacks->parse_sentence, $fragment->innertext);
        }
      }

    if ($this->changed) { $this->html->load($this->html->save()); }

    // Step II - parse terms that are single words.
    foreach ($this->html->find('text') as $fragment) {
      if (!$this->in_excluded_tag($fragment)) {
        $fragment->innertext = preg_replace_callback($this->re->words, $this->callbacks->parse_fragment, $fragment->innertext);
      }
    }

    // Step III - generate tooltips.
    if ($this->changed) {
      $ttips = $this->use_tooltips ? $this->generate_tooltips() : '';
      $out = $this->html->outertext . $ttips;
      unset($ttips);
    }
    else {
      $out = $this->src;
    }
    $this->html->clear();
    unset($this->html, $fragment, $vid, $vname, $term, $tax, $ltax, $rgx, $terms_regex);
    return $out;
  }

  private function parse_fragment($matches) {
    if (!isset($matches[0])) { return ''; }
    $tax  = &$this->taxonomy();
    $word = '';
    $pref = '';

    // upper-case word at the beginning of a sentence
    if (!empty($matches[3])) {
      $word = $matches[3];
      $pref = $matches[2];
      $lc = $this->lcfirst($word);
      if (array_key_exists($lc, $tax)) {
        return $pref . $this->generate_link($word, $lc);
      }
    } //  word inside of a sentence
    elseif (!empty($matches[4])) {
      $word = $matches[4];
    }
    else { return $matches[0]; }

    if (array_key_exists($word, $tax)) {
      return $pref . $this->generate_link($word);
    }

    return $matches[0];
  }

  private function parse_sentence($matches) {
    if (!isset($matches[0])) { return ''; }
    $tax  = &$this->taxonomy();
    //dpm($matches);
    $pref = '';
    $suff = '';
    $word = '';
    if (!empty($matches[6])) {
      $pref = $matches[5];
      $word = $matches[6];
      $suff = $matches[7];
    }
    elseif (!empty($matches[3])) {
      $pref = $matches[2];
      $word = $matches[3];
      $lc = $this->lcfirst($word);
      if (array_key_exists($lc, $tax)) {
        return $pref . $this->generate_link($word, $lc);
      }
    }
    else { return $matches[0]; }

    if (array_key_exists($word, $tax)) {
      return $pref . $this->generate_link($word) . $suff;
    }

    return $matches[0];
  }

  private function ucfirst($name) {
    return drupal_strtoupper(drupal_substr($name, 0, 1)) .
           drupal_substr($name, 1);
  }

  private function lcfirst($name) {
    return drupal_strtolower(drupal_substr($name, 0, 1)) .
           drupal_substr($name, 1);
  }

  private function generate_link($word, $orig = NULL) {
    if (!$this->changed) { $this->changed = TRUE; }
    $tax  = &$this->taxonomy();
    $tips = &$this->tooltips();
    if (is_null($orig)) { $orig = $word; }
    $tid  = $tax[$orig];
    $tip  = array_key_exists($tid, $tips) ? $tips[$tid]['tip'] : '';
    $tiprefstring = '';
    if ($this->use_tooltips && !empty($tip)) {
      if (!array_key_exists($orig, $this->used_tips)) {
        $this->used_tips[$orig] = $tid;
      }
      $tiprefstring = 'id="tooltip-ref-' . $tid . '"';
    }
    unset($tip);
    return '<a href="' . url('taxonomy/term/' . $tid) . '" title="' . $orig . '" ' .
           'class="taxonomy-autolink"' . $tiprefstring . '>' . $word . '</a>';
  }

  private function generate_tooltips() {
    $r = "\n" . '<!-- tooltips -->' . "\n";
    $r .= '<div id="tooltips-container" style="display:none;">' . "\n";
    $r .= '<p>Tooltips:</p>' . "\n";
    $tips = &$this->tooltips();
    foreach($this->used_tips as $name => $tid) {
      $orign = $tips[$tid]['orig'];
      $th = $name;
      if (drupal_strtolower($orign) !== drupal_strtolower($name)) {
        $th .= ' ' . t('(orig. @original_term)', array('@original_term' => $orign));
      }
      $r .= '  ' . '<h3 class="tooltip-header">' . $th . '</h3>' . "\n";
      $r .= '  <div id="tooltip-def-' . $tid . '">' . $tips[$tid]['tip'];
      $r .= '  </div>' . "\n";
    }
    $r .= "</div>\n<!--eof tooltips -->\n";
    return $r;
  }

  public function clear() {
    unset($this->src, $this->query, $this->used_tips);
  }
}

