<?php

/**
* @file
* autolink_filter.module
* 
* @author PaweÅ‚ Wilk
* @link http://github.com/siefca/autolink_filter
*
* Provides automatic linking filter for input formats.
*/

/**
* Gets vocabularies as an array.
*/
function _autolink_filter_vocab_array() {
  $checklist_vocab_array = array();
  $vocabulary = taxonomy_get_vocabularies();
  foreach ($vocabulary as $item) {
    $checklist_vocab_array[$item->vid] = $item->name;
  }
  unset($item);
  return $checklist_vocab_array;
}

/**
* Implements hook_init().
*/
function autolink_filter_init() {
  $path = drupal_get_path('module', 'autolink_filter');
}

/**
* Implements hook_filter_info().
*/
function autolink_filter_filter_info() {
  $filters = array();
  $excluded_tags  = 'a link pre h1 h2 h3 h4 h5 h6 h7 code pre address';
  $excluded_words = 'or of because and but no yes though because they i you he she it since are were have had been m very' . 
                    'less also to too then when';
  $filters['autolink_filter'] = array(
    'title' => t('Automatically link keywords from vocabularies'),
    'process callback'  => '_autolink_filter_process_filter',
    'settings callback' => '_autolink_filter_settings',
    'weight' => 50,
    'default settings' => array(
      'excluded_tags'   => $excluded_tags,
      'excluded_words'  => $excluded_words,
      'vocabularies'    => _autolink_filter_vocab_array(),
    )
  );
  return $filters;
}

/**
* Filter process callback.
*/
function _autolink_filter_process_filter($text, $filter) {
  $vocs = $filter->settings['vocabularies'];
  $excl_tags = $filter->settings['excluded_tags'];
  $excl_words = $filter->settings['excluded_words'];
  $min = 0;
  $max = 0; // fixme!
  if (!isset($vocs) || empty($vocs)) { return $text; }
  if (!isset($excl)) { $excl = ""; }
  $parser = new AutolinkFilterParser($text, $vocs, $excl_tags, $excl_words, $min, $max);
  $r = $parser->parse();
  $parser->clear();
  unset($vocs, $excl_tags, $excl_words);
  return $r;
}

/**
* Adds query taxonomy_leaf tag.
*/
function autolink_filter_query_taxonomy_leaf_alter(QueryAlterableInterface $query) {
  $tables =& $query->getTables();
  $query
    ->leftJoin('taxonomy_term_hierarchy', 'parents', 'parents.parent = ' . $tables['taxonomy_term_data']['alias'] . '.tid');
  $query
    ->isNull('parents.parent');  
}

/**
* Parser class
*/
class AutolinkFilterParser {
  private $src;         // source text
  private $html;        // HTML DOM
  private $min_length;  // minimal length of parsed word
  private $max_length;  // maximal length of parsed word
  private $leaves_only; // use only taxonomy terms that are not parents of other terms
  private $taxonomy;    // taxonomy words
  private $changed;     // internal change marker
  private $used_tips;   // used term ID-s

  function __construct($src, $vocs, $excluded_tags = '', $excluded_words = '', $min_length = 0,
                       $max_length = 0, $leaves_only = TRUE) {

    if (!is_numeric($min_length) || $min_length < 0) { $min_length = 0; }
    if (!is_numeric($max_length) || $max_length < 0) { $max_length = 0; }
    if ($min_length > 32)  { $min_length = 32; }
    if ($max_length === 0 || $max_length > 1024) { $max_length = 1024; }

    $this->src            = $src;
    $this->taxonomy       = array();
    $this->vocabularies   = array();
    $this->leaves_only    = $leaves_only;
    $this->min_length     = $min_length;
    $this->max_length     = $max_length;
    $this->excluded_tags  = $this->extract_words_as_keys(drupal_strtolower($excluded_tags));
    $this->excluded_words = $this->extract_words_as_keys($excluded_words, $this->min_length, $this->max_length);

    foreach($vocs as $vid => $name) {
      if ($name) {
        $this->vocabularies[] = $vid;
      }
    }

    $this->load_taxonomy();
    //dpm($this->taxonomy);
  }

  private function load_taxonomy() {
    $query = new EntityFieldQuery;
    $query
      ->entityCondition('entity_type', 'taxonomy_term')
      ->propertyCondition('vid', $this->vocabularies, 'IN')
      ->propertyOrderBy('weight');
    if ($this->leaves_only) { $query->addTag('taxonomy_leaf'); }
    $terms = $query->execute();
    if (isset($terms['taxonomy_term'])) {
      $terms = entity_load('taxonomy_term', array_keys($terms['taxonomy_term']));
      //dpm($terms);
      foreach($terms as $term) {
        if (isset($term->name)) {
          $name = $term->name;
          $name_length = drupal_strlen($name);
          if ($name_length < $this->min_length || $name_length > $this->max_length ||
              array_key_exists($name, $this->excluded_words) ||
              array_key_exists($name, $this->taxonomy)) { continue; }
          $tip = isset($term->tooltip) ? $term->tooltip : '';
          $this->taxonomy[$name] = array($term->tid, $tip);
        }
      }
    }
    unset($terms, $query, $term, $tip, $name, $name_length);
  }

  private function extract_words($text, $minlength = 0, $maxlength = 0) {
    static $re_wordsplit = '/[^\pL\p{Pc}\p{Pd}\pN\/]+/u';
    if (($minlength + $maxlength) === 0) {
      return array_filter(preg_split($re_wordsplit, $text));
    }
    else {
      $r = $this->extract_words($text);
      foreach ($r as $k => $word) {
        $l = drupal_strlen($word);
        if ($l < $minlength || $l > $maxlength) {
          unset($r[$k]);
        }
      }
      unset($k, $word);
      return $r;
    }
  }

  private function extract_words_as_keys($text, $minl = 0, $maxl = 0) {
    return array_flip($this->extract_words($text, $minl, $maxl));
  }

  private function extract_words_from_text($text) {
    return array_flip($this->extract_words($text), $this->min_length, $this->max_length);
  }

  private function in_excluded_tag(& $el) {
    if (!isset($el->parent)) { return FALSE; }
    if (array_key_exists($el->parent->tag, $this->excluded_tags)) { return TRUE; }
    return $this->in_excluded_tag($el->parent);
  }

  public function parse() {
    static $re_words = '/[\pL\p{Pc}\p{Pd}\pN\/]+/u';
    $this->changed = FALSE;
    $this->used_tips = array();
    $this->html = new simple_html_dom();
    $this->html->load($this->src, true, false);
    foreach ($this->html->find('text') as $fragment) {
      if (!$this->in_excluded_tag($fragment)) {
        $fragment->innertext = preg_replace_callback($re_words, array(&$this, 'parse_fragment'), $fragment->innertext);
      }
    }
    $out = $this->changed ? $this->html->outertext . $this->generate_tooltips() : $this->src;
    $this->html->clear();
    unset($this->html, $fragment, $vid, $vname);
    return $out;
  }

  private function parse_fragment($matches) {
    if (!isset($matches[0])) { return ''; }
    $word = $matches[0];
    if (array_key_exists($word, $this->taxonomy)) {
      if (!$this->changed) { $this->changed = TRUE; }
      list($tid, $tip) = $this->taxonomy[$word];
      $tiprefstring = '';
      if (!empty($tip)) {
        if (!array_key_exists($tid, $this->used_tips)) {
          $this->used_tips[$word] = $tid;
        }
        $tiprefstring = 'id="tooltip-ref-' . $tid . '"';
      }
      return '<a href="' . url('taxonomy/term/' . $tid) . '" title="' . $word . '" ' .
             'class="taxonomy-autolink"' . $tiprefstring . '>' . $word . '</a>';
    }
    else {
      return $word;
    }
  }

  private function generate_tooltips() {
    $r = "\n" . '<!-- tooltips -->' . "\n";
    $r .= '<div id="tooltips-container" style="display:none;">' . "\n";
    $r .= '<p>Tooltips:</p>' . "\n";
    foreach($this->used_tips as $name => $tid) {
      $r .= '  <div id="tooltip-def-' . $tid . '">' . $this->taxonomy[$name][1] . '</div>' . "\n";
    }
    $r .= "</div>\n<!--eof tooltips -->\n";
    return $r;
  }

  public function clear() {
    unset($this->src, $this->query, $this->taxonomy, $this->used_tips);
  }
}

/**
 * Settings callback.
 */
function _autolink_filter_settings($form, &$form_state, $filter, $format, $defaults, $filters) {
  $filter->settings += $defaults;
  return array(
    'reminder' => array(
      '#type'   => 'item',
      '#title'  => t('In most cases, Autolink Filter should be the <em>last</em> filter in the &ldquo;Filter processing order&rdquo; list.'),
      '#weight' => -10,
    ),
    'excluded_tags' => array(
      '#type'           => 'textfield',
      '#title'          => t('HTML tags excluded from processing.'),
      '#default_value'  => $filter->settings['excluded_tags'],
      '#size'           => '63',
      '#weight'         => -5,
      '#description'    => t('Enter HTML tag names (separated by spaces and/or commas) which content (contained within) will not be processed.'),
    ),
     'excluded_words' => array(
        '#type'           => 'textfield',
        '#title'          => t('Words excluded from processing.'),
        '#default_value'  => $filter->settings['excluded_words'],
        '#size'           => '63',
        '#weight'         => -2,
        '#description'    => t('Enter words (separated by spaces and/or commas) which won\'t be processed.'),
    ),
    'vocabularies' => array(
      '#type'           => 'checkboxes',
      '#title'          => t('Vocabularies'),
      '#position'       => 'left',
      '#options'        => _autolink_filter_vocab_array(),
      '#default_value'  => $filter->settings['vocabularies'],
      '#description'    => t('Select taxonomy vocabularies used to automatically link keywords.'),
    )
  );
}

/**
 * Delete unneeded things after uninstalling.
 */
function autolink_filter_delete_all() {
  cache_clear_all('*', 'cache_filter');
}
