<?php

/**
* @file
* autolink_filter.module
* 
* @author PaweÅ‚ Wilk
* @link http://github.com/siefca/autolink_filter
*
* Provides automatic linking filter for input formats.
*/

/**
* Implements hook_init().
*/
function autolink_filter_init() {
  $path = drupal_get_path('module', 'autolink_filter');
}

/**
* Implements hook_filter_info().
*/
function autolink_filter_filter_info() {
  $filters          = array();
  $excluded_tags    = 'a link pre h1 h2 h3 h4 h5 h6 h7 code pre address';
  $excluded_classes = 'nolink';
  $excluded_words   = 'or of because and but no yes though because they i you he she it since are were have had been m very' . 
                      'less also to too then when';
  $filters['autolink_filter'] = array(
    'title'             => t('Automatically link keywords from vocabularies'),
    'process callback'  => '_autolink_filter_process_filter',
    'settings callback' => '_autolink_filter_settings',
    'weight'            => 50,
    'default settings'  => array(
      'excluded_tags'   => $excluded_tags,
      'excluded_classes'=> $excluded_classes,
      'excluded_words'  => $excluded_words,
      'vocabularies'    => _autolink_filter_vocab_array(),
      'processing_options' => array('use_tooltips', 'use_synonyms'),
      'min'             => 2,
      'max'             => 32,
    ),
  );
  return $filters;
}

/**
* Renders processing options array.
*/
function _autolink_filter_processing_options_array() {
  return array(
    'leaves_only'   => t('Only use terms that are the last children (leaves) of a taxonomy tree.'),
    'selected_only' => t('Only use terms that have <code>field_autolink</code> boolean field set.'),
    'use_tooltips'  => t('Generate tooltips (uses <code>field_autolink_tooltip</code> text fields from taxonomy terms).'),
    'use_synonyms'  => t('Use taxonomy synonyms if available.'),
  );
}

/**
* Gets vocabularies as an array.
*/
function _autolink_filter_vocab_array() {
  $checklist_vocab_array = array();
  $vocabulary = taxonomy_get_vocabularies();
  foreach ($vocabulary as $item) {
    $checklist_vocab_array[$item->vid] = $item->name;
  }
  unset($item);
  return $checklist_vocab_array;
}

/**
 * Settings callback.
 */
function _autolink_filter_settings($form, &$form_state, $filter, $format, $defaults, $filters) {
  $filter->settings += $defaults;
  return array(
    'reminder' => array(
      '#type'   => 'item',
      '#title'  => t('In most cases, Autolink Filter should be the <em>last</em> filter in the &ldquo;Filter processing order&rdquo; list. It is also recommended to run &ldquo;@htmlcorrector_name&rdquo; after this filter, when tooltips are in use.', array('@htmlcorrector_name' => t('Correct faulty and chopped off HTML'))),
      '#weight' => -20,
    ),
    'processing_options' => array(
      '#type'           => 'checkboxes',
      '#title'          => t('Processing options'),
      '#position'       => 'left',
      '#options'        => _autolink_filter_processing_options_array(),
      '#default_value'  => $filter->settings['processing_options'],
      '#weight'         => -5,
      '#description'    => t('Select desirable processing options.'),
    ),
    'excluded_tags' => array(
      '#type'           => 'textfield',
      '#title'          => t('HTML tags excluded from processing'),
      '#default_value'  => $filter->settings['excluded_tags'],
      '#size'           => '63',
      '#weight'         => -10,
      '#description'    => t('Enter HTML tag names (separated by spaces and/or commas) for which a content (contained within) will not be processed.'),
    ),
    'excluded_classes' => array(
      '#type'           => 'textfield',
      '#title'          => t('HTML classes excluded from processing'),
      '#default_value'  => $filter->settings['excluded_classes'],
      '#size'           => '63',
      '#weight'         => -8,
      '#description'    => t('Enter HTML class attribute values (separated by spaces and/or commas) for which a content (contained within) will not be processed.'),
    ),
    'excluded_words' => array(
      '#type'           => 'textfield',
      '#title'          => t('Words excluded from processing'),
      '#default_value'  => $filter->settings['excluded_words'],
      '#size'           => '63',
      '#weight'         => -7,
      '#description'    => t('Enter words (separated by spaces and/or commas) which won\'t be processed.'),
    ),
    'min'               => array(
      '#type'           => 'textfield',
      '#title'          => t('Minimum length of a word'),
      '#default_value'  => $filter->settings['min'],
      '#size'           => '3',
      '#maxlength'      => '4',
      '#element_validate' => array('_autolink_filter_length_validate'),
      '#weight'         => -4,
      '#description'    => t('The minimum acceptable number of letters in a word to be processed (@min to @max)',
                            array('@min' => 0, '@max' => 32)),
    ),
      'max'             => array(
      '#type'           => 'textfield',
      '#title'          => t('Maximum length of a word'),
      '#default_value'  => $filter->settings['max'],
      '#size'           => '3',
      '#maxlength'      => '4',
      '#element_validate' => array('_autolink_filter_length_validate'),
      '#weight'         => -2,
      '#description'    => t('The maximum acceptable number of letters in a word to be processed (@min to @max)',
                            array('@min' => 1, '@max' => 32)),
    ),
    'vocabularies' => array(
      '#type'           => 'checkboxes',
      '#title'          => t('Vocabularies'),
      '#position'       => 'left',
      '#options'        => _autolink_filter_vocab_array(),
      '#default_value'  => $filter->settings['vocabularies'],
      '#weight'         => 0,
      '#description'    => t('Select taxonomy vocabularies used to automatically link keywords.'),
    )
  );
}

/**
 * Element validate callback for fields that contain lengths.
 */
function _autolink_filter_length_validate($element, $form_state, $form) {
  if (!empty($element['#value']) && !is_numeric($element['#value'])) {
    form_error($element, $element['#title'] . ' ' . t('should only contain numbers.'));
  }

  settype($element['#value'], 'integer');
  $val = $element['#value'];
  $errv = FALSE;
  if ($val > 32) {
    $errv = 'should not be greater than 32';
  }
  else {
    switch(end($element['#array_parents'])) {
      case 'min':
        if ($val < 0) { $errv = 0; }
        break;
      case 'max':
        if ($val < 1) { $errv = 1; }
        break;
    }
    if ($errv !== FALSE) { $errv = t('should be equal or greater than') . ' ' . $errv; }
  }
  if ($errv !== FALSE) { form_error($element, $element['#title'] . ' ' . $errv . '.'); }
}

/**
* Filter process callback.
*/
function _autolink_filter_process_filter($text, $filter) {
  $s                  = $filter->settings;
  $min                = $s['min'];
  $max                = $s['max'];
  $vocs               = $s['vocabularies'];
  $excl_tags          = $s['excluded_tags'];
  $excl_words         = $s['excluded_words'];
  $excl_classes       = $s['excluded_classes'];
  $processing_options = array_filter($filter->settings['processing_options']);
  $leaves_only        = array_key_exists('leaves_only',   $processing_options);
  $selected_only      = array_key_exists('selected_only', $processing_options);
  $use_tooltips       = array_key_exists('use_tooltips',  $processing_options);
  $use_synonyms       = array_key_exists('use_synonyms',  $processing_options);

  if (!isset($vocs) || empty($vocs)) { return $text; }
  if (!isset($excl_tags)    || empty($excl_tags))     { $excl_tags     = NULL; }
  if (!isset($excl_words)   || empty($excl_words))    { $excl_words    = NULL; }
  if (!isset($excl_classes) || empty($excl_classes))  { $excl_classes  = NULL; }
  if (!isset($leaves_only))                           { $leaves_only   = NULL; }
  if (!isset($selected_only))                         { $selected_only = NULL; }
  if (!isset($use_tooltips))                          { $use_tooltips  = NULL; }
  if (!isset($use_synonyms))                          { $use_synonyms  = NULL; }
  if (!is_integer($min))                              { settype($min, 'integer'); }
  if (!is_integer($max))                              { settype($max, 'integer'); }

  $parser = new AutolinkFilterParser($text, $vocs, $excl_tags, $excl_classes, $excl_words, $min, $max,
                                     $leaves_only, $use_tooltips, $selected_only, $use_synonyms);

  $r = $parser->parse();
  $parser->clear();
  unset($vocs, $excl_tags, $excl_words, $excl_classes, $s);
  return $r;
}

/**
* Adds query autolink_sieve tag for filtering by explicite boolean marker
* (if it's not 0 and not null).
*/
function autolink_filter_query_autolink_sieve_alter(QueryAlterableInterface $query) {
  $sieve_field = $query->getMetaData('sieve_field');
  if ($sieve_field === NULL) { return; }
  $sieve_table = 'field_data_' . $sieve_field;
  if(!db_table_exists($sieve_table)) { return; }
  $sieve_value_field = $sieve_field . '_value';
  if(!db_field_exists($sieve_table, $sieve_value_field) || !db_field_exists($sieve_table, 'entity_id')) {
    $query->condition('0', '1', '=');
    return;
  }
  $tables =& $query->getTables();
  $query
    ->join($sieve_table, 'enabled', 'enabled.entity_id = ' . $tables['taxonomy_term_data']['alias'] . '.tid');
  $query
    ->isNotNull('enabled.' . $sieve_value_field);
  $query
    ->condition('enabled.' . $sieve_value_field, 0, '<>');
}

/**
* Adds query autolink_leaves tag for using the last children of taxonomy tree.
*/
function autolink_filter_query_autolink_leaves_alter(QueryAlterableInterface $query) {
  $tables =& $query->getTables();
  $query
    ->leftJoin('taxonomy_term_hierarchy', 'parents', 'parents.parent = ' . $tables['taxonomy_term_data']['alias'] . '.tid');
  $query
    ->isNull('parents.parent');  
  //dpm($query->__toString());
}

/**
* Adds query autolink_group_by_name tag for removing duplicated names when multiple matches occur.
*/
function autolink_filter_query_autolink_group_by_name_alter(QueryAlterableInterface $query) {
  $tables =& $query->getTables();
  $query
    ->groupBy($tables['taxonomy_term_data']['alias'] . '.name');
}

/**
* Adds query autolink_order_by_length tag for removing duplicated names when multiple matches occur.
*/
function autolink_filter_query_autolink_order_by_length_alter(QueryAlterableInterface $query) {
  $fn = _autolink_sql_length_clause($query);
  $tables =& $query->getTables();
  $td = $tables['taxonomy_term_data']['alias'];
  if ($query->getMetaData('use_tooltips') === TRUE && db_table_exists('field_data_field_autolink_tooltip')) {
    $query
      ->leftJoin('field_data_field_autolink_tooltip', 'ttips',
                 'ttips.entity_id = ' . $td . '.tid AND ttips.entity_type = taxonomy_term');
    $query
      ->orderBy($fn . '(ttips.field_autolink_tooltip_value)', 'DESC');
  }
  $query
    ->orderBy($fn . '(' . $td . '.description)', 'DESC');
}

/**
* Adds query taxonomy_name_length tag for filtering out names that have unwanted lengths.
*/
function autolink_filter_query_taxonomy_name_length_alter(QueryAlterableInterface $query) {
  $fn = _autolink_sql_length_clause($query);
  $tables =& $query->getTables();
  $tname = $tables['taxonomy_term_data']['alias'];
  $min = $query->getMetaData('name_length_min');
  $max = $query->getMetaData('name_length_max');
  $query
    ->where($fn . '(' . $tname . '.name) >= ' . $min);
  $query
    ->where($fn . '(' . $tname . '.name) <= ' . $max);
}

function _autolink_sql_length_clause($query) {
  static $fn = NULL;
  if ($fn === NULL) {
    $fn = (_autolink_filter_read_property($query, 'connection')->databaseType() == 'sqlite') ? 'LENGTH' : 'CHAR_LENGTH';
  }
 return $fn; 
}

/**
 * Delete unneeded things after uninstalling.
 */
function autolink_filter_delete_all() {
  cache_clear_all('*', 'cache_filter');
}

function _autolink_filter_read_property($class, $propertyName)
{
    $reflectedClass = new ReflectionClass($class);
    $property = $reflectedClass->getProperty($propertyName);
    $property->setAccessible(true);
    return $property->getValue($class);
}

/**
* Parser class
*/
class AutolinkFilterParser {
  private $src;               // source text
  private $html;              // HTML DOM
  private $min_length;        // minimal length of parsed word
  private $max_length;        // maximal length of parsed word
  private $leaves_only;       // use only taxonomy terms that are not parents of other terms
  private $use_tooltips;      // use tooltips
  private $selected_only;     // require field_autolink to be true
  private $use_synonyms;      // uses synonyms
  private $changed;           // internal change marker
  private $used_tips;         // used term ID-s
  private $use_synonyms_real; // deduced ability to use synonyms
  private $callbacks;         // arrays for preg_replace method with callback method names

  private static $taxonomy      = array();  // taxonomy words
  private static $tooltips      = array();  // taxonomy tooltips
  private static $taxonomy_sum  = '';       // taxonomy sum (for caching)
  private static $chunk_size    = 20;       // number of taxonomy items to load and process at once (takes care of memory)

  function __construct($src, $vocs, $excluded_tags = '', $excluded_classes = '', $excluded_words = '', $min_length = 0,
                       $max_length = 0, $leaves_only = FALSE, $use_tooltips = TRUE, $selected_only = FALSE,
                       $use_synonyms = 1) {

    if (is_null($vocs))             { $vocs = array();              }
    if (is_null($excluded_tags))    { $excluded_tags    = array();  }
    if (is_null($excluded_words))   { $excluded_words   = array();  }
    if (is_null($excluded_classes)) { $excluded_classes = array();  }
    if (is_null($leaves_only))      { $leaves_only      = FALSE;    }
    if (is_null($selected_only))    { $selected_only    = FALSE;    }
    if (is_null($use_tooltips))     { $use_tooltips     = FALSE;    }
    if (is_null($use_synonyms))     { $use_synonyms     = FALSE;    }

    if (!is_numeric($min_length) || $min_length < 0)    { $min_length = 0;  }
    if (!is_numeric($max_length) || $max_length < 0)    { $max_length = 0;  }
    if ($min_length > 255)  { $min_length = 255; }
    if ($max_length == 0 || $max_length > 255) { $max_length = 255; }

    $this->src              = $src;
    $this->vocabularies     = array();
    $this->leaves_only      = $leaves_only;
    $this->min_length       = $min_length;
    $this->max_length       = $max_length;
    $this->use_tooltips     = $use_tooltips;
    $this->selected_only    = $selected_only;
    $this->use_synonyms     = $use_synonyms;
    $this->excluded_tags    = $this->extract_words_as_keys(drupal_strtolower($excluded_tags));
    $this->excluded_words   = $this->extract_words($excluded_words, $this->min_length, $this->max_length);
    $this->excluded_classes = $this->extract_words_as_keys(drupal_strtolower($excluded_classes));

    $this->callbacks->parse_fragment = array(&$this, 'parse_fragment');
    $this->callbacks->parse_sentence = array(&$this, 'parse_sentence');

    foreach($vocs as $vid => $name) {
      if ($name) {
        $this->vocabularies[] = $vid;
      }
    }

    $this->load_taxonomy();
  }

  private function load_taxonomy() {
    $this->use_synonyms_real = ($this->use_synonyms && db_table_exists('field_data_synonyms_synonyms'));
    $cache_key = '-' . $this->min_length    . '-' . $this->max_length         .
                 '-' . $this->leaves_only   . '-' . $this->selected_only      .
                 '-' . $this->use_tooltips  . '-' . $this->use_synonyms_real  .
                 '-' . implode(':', $this->excluded_words)  .
                 '-' . implode(':', $this->vocabularies);

    if (self::$taxonomy_sum === $cache_key) { return; }
    self::$taxonomy = array();
    self::$tooltips = array();

    // Query for taxonomy terms.
    $query = new EntityFieldQuery;
    $query
      ->entityCondition('entity_type', 'taxonomy_term')
      ->propertyCondition('vid',  $this->vocabularies, 'IN')
      ->propertyCondition('name', $this->excluded_words, 'NOT IN')
      ->propertyOrderBy('name')
      ->propertyOrderBy('weight')
      ->addMetaData('use_tooltips', TRUE)
      ->addTag('autolink_order_by_length');

    // Do not filter lengths and don't group by name when using synonyms,
    // but do it later when post-processing taxonomy entities. We don't want
    // synonyms to be dropped just because main term is not meeting certain criteria.
    if (!$this->use_synonyms_real) {
      $query
        ->addMetaData('name_length_min', $this->min_length)
        ->addMetaData('name_length_max', $this->max_length)
        ->addTag('taxonomy_name_length')
        ->addTag('autolink_group_by_name');
    }

    if ($this->selected_only) {
      $query
        ->addMetaData('sieve_field', 'field_autolink')
        ->addTag('autolink_sieve');
    }

    if ($this->leaves_only) {
      $query
        ->addTag('autolink_leaves');
    }

    // Collect taxonomy terms.
    $synonyms = array();
    $needed_terms = array();
    $tterms = $query->execute();
    if (isset($tterms['taxonomy_term'])) {
      $tidgroups = array_chunk(array_keys($tterms['taxonomy_term']), self::$chunk_size); 
      foreach($tidgroups as $tids) {
        $terms = entity_load('taxonomy_term', $tids);
        foreach($terms as $term) {
          if (isset($term->name)) {
            if ($this->use_synonyms_real) {
              $synonyms = $this->extract_synonyms($term);
              foreach($synonyms as $synonym_name) {      
                $this->memorize_term_data($term, $synonym_name);
              }
            }
            $this->memorize_term_data($term);
          }
        }
      }
    }

    self::$taxonomy_sum = $cache_key;
    unset($terms, $tterms, $synonyms, $synonym_name, $term, $query, $tip, $cache_key, $tids, $name, $name_length, $tidgroups);
  }

  private function memorize_term_data($term, $use_name = FALSE) {
    if ($use_name === FALSE) { $use_name = $term->name; }
    if ($this->use_synonyms_real) {
      $l = drupal_strlen($use_name);
      if ($l < $this->min_length || $l > $this->max_length) { return; }
      if (array_key_exists($use_name, self::$taxonomy))     { return; }
    }
    self::$taxonomy[$use_name] = $term->tid;
    if ($this->use_tooltips && isset($term->autolink_tooltip)) {
      if (!array_key_exists($term->tid, self::$tooltips)) {
        self::$tooltips[$term->tid] = array('tip' => $term->autolink_tooltip, 'orig' => $term->name);
      }
    }
    unset($l, $term, $use_name, $orign);
  }

  private function extract_synonyms($term) {
    $r = array();
    if (isset($term->synonyms_synonyms) && isset($term->synonyms_synonyms['und'])) { 
      foreach($term->synonyms_synonyms['und'] as $s) {
        if (isset($s['safe_value'])) {
          $r[] = $s['safe_value'];
        }
        elseif (isset($s['value'])) {
          $r[] = $s['value'];
        }
      }
    }
    return $r;
  }

  private function extract_words($text, $minlength = 0, $maxlength = 0) {
    static $re_wordsplit = '/[^\pL\p{Pc}\p{Pd}\pN\/]+/u';
    if (($minlength + $maxlength) === 0) {
      return array_filter(preg_split($re_wordsplit, $text));
    }
    else {
      $r = $this->extract_words($text);
      foreach ($r as $k => $word) {
        $l = drupal_strlen($word);
        if ($l < $minlength || $l > $maxlength) {
          unset($r[$k]);
        }
      }
      unset($k, $word);
      return $r;
    }
  }

  private function extract_words_as_keys($text, $minl = 0, $maxl = 0) {
    return array_flip($this->extract_words($text, $minl, $maxl));
  }

  private function extract_words_from_text($text) {
    return array_flip($this->extract_words($text), $this->min_length, $this->max_length);
  }

  private function in_excluded_tag(& $el) {
    if (!isset($el->parent)) { return FALSE; }
    $p = & $el->parent;

    if ($p->hasAttribute('class')) {
      $classes = array_flip(preg_split('/\s/', $p->class));
      if (array_intersect_key($classes, $this->excluded_classes)) {
        unset($classes);
        return TRUE;
      }
      unset($classes);
    }

    if (array_key_exists($p->tag, $this->excluded_tags)) { return TRUE; }

    return $this->in_excluded_tag($p);
  }

  public function parse() {
    static $re_words = '/[\pL\p{Pc}\p{Pd}\pN\/]+/u';
    static $pa_wordsplit_beg = '/(^|[^\pL\p{Pc}\p{Pd}\pN\/]+)(';
    static $pa_wordsplit_end = ')($|[^\pL\p{Pc}\p{Pd}\pN\/]+)/u';
    $this->changed = FALSE;
    $this->used_tips = array();
    $this->html = new simple_html_dom();
    $this->html->load($this->src, true, false);
    
    // Step I - parse terms that have multiple words.
    foreach (self::$taxonomy as $term => $tid) {
      if(strpos($term, ' ') !== FALSE) {
        foreach ($this->html->find('text') as $fragment) {
          if (!$this->in_excluded_tag($fragment)) {
            $rgx = $pa_wordsplit_beg . preg_quote($term) . $pa_wordsplit_end; // todo: add some chunking here and joint regex
            $fragment->innertext = preg_replace_callback($rgx, $this->callbacks->parse_sentence, $fragment->innertext);
          }
        }
      }
    }

    if ($this->changed) { $this->html->load($this->html->save()); }

    // Step II - parse terms that are single words.
    foreach ($this->html->find('text') as $fragment) {
      if (!$this->in_excluded_tag($fragment)) {
        $fragment->innertext = preg_replace_callback($re_words, $this->callbacks->parse_fragment, $fragment->innertext);
      }
    }

    // Step III - generate tooltips.
    if ($this->changed) {
      $ttips = $this->use_tooltips ? $this->generate_tooltips() : '';
      $out = $this->html->outertext . $ttips;
      unset($ttips);
    }
    else {
      $out = $this->src;
    }
    $this->html->clear();
    unset($this->html, $fragment, $vid, $vname, $term);
    return $out;
  }

  private function parse_fragment($matches) {
    if (!isset($matches[0])) { return ''; }
    $word = $matches[0];
    if (array_key_exists($word, self::$taxonomy)) {
      return $this->generate_link($word);
    }
    else {
      return $word;
    }
  }

  private function parse_sentence($matches) {
    if (!isset($matches[0])) { return ''; }
    return $matches[1] . $this->generate_link($matches[2]) . $matches[3];
  }

  private function generate_link($word) {
    if (!$this->changed) { $this->changed = TRUE; }
    $tid = self::$taxonomy[$word];
    $tip = array_key_exists($tid, self::$tooltips) ? self::$tooltips[$tid]['tip'] : '';
    $tiprefstring = '';
    if ($this->use_tooltips && !empty($tip)) {
      if (!array_key_exists($tid, $this->used_tips)) {
        $this->used_tips[$word] = $tid;
      }
      $tiprefstring = 'id="tooltip-ref-' . $tid . '"';
    }
    unset($tip);
    return '<a href="' . url('taxonomy/term/' . $tid) . '" title="' . $word . '" ' .
           'class="taxonomy-autolink"' . $tiprefstring . '>' . $word . '</a>';
  }

  private function generate_tooltips() {
    $r = "\n" . '<!-- tooltips -->' . "\n";
    $r .= '<div id="tooltips-container" style="display:none;">' . "\n";
    $r .= '<p>Tooltips:</p>' . "\n";
    foreach($this->used_tips as $name => $tid) {
      $orign = self::$tooltips[$tid]['orig'];
      $th = $name;
      if ($orign !== $name) {
        $th .= ' ' . t('(i.e. @original_term)', array('@original_term' => $orign));
      }
      $r .= '  ' . '<h3 class="tooltip-header">' . $th . '</h3>' . "\n";
      $r .= '  <div id="tooltip-def-' . $tid . '">' . self::$tooltips[$tid]['tip'];
      $r .= '  </div>' . "\n";
    }
    $r .= "</div>\n<!--eof tooltips -->\n";
    return $r;
  }

  public function clear() {
    unset($this->src, $this->query, $this->used_tips);
  }
}

